List of algorithms üèÜ
=====================

Contents
--------

*   [1 Automated planning](#Automated_planning)
*   [2 Combinatorial algorithms](#Combinatorial_algorithms)
    *   [2.1 General combinatorial algorithms](#General_combinatorial_algorithms)
    *   [2.2 Graph algorithms](#Graph_algorithms)
        *   [2.2.1 Graph drawing](#Graph_drawing)
        *   [2.2.2 Network theory](#Network_theory)
        *   [2.2.3 Routing for graphs](#Routing_for_graphs)
        *   [2.2.4 Graph search](#Graph_search)
        *   [2.2.5 Subgraphs](#Subgraphs)
    *   [2.3 Sequence algorithms](#Sequence_algorithms)
        *   [2.3.1 Approximate sequence matching](#Approximate_sequence_matching)
        *   [2.3.2 Selection algorithms](#Selection_algorithms)
        *   [2.3.3 Sequence search](#Sequence_search)
        *   [2.3.4 Sequence merging](#Sequence_merging)
        *   [2.3.5 Sequence permutations](#Sequence_permutations)
        *   [2.3.6 Sequence alignment](#Sequence_alignment)
        *   [2.3.7 Sequence sorting](#Sequence_sorting)
        *   [2.3.8 Subsequences](#Subsequences)
        *   [2.3.9 Substrings](#Substrings)
*   [3 Computational mathematics](#Computational_mathematics)
    *   [3.1 Abstract algebra](#Abstract_algebra)
    *   [3.2 Computer algebra](#Computer_algebra)
    *   [3.3 Geometry](#Geometry)
    *   [3.4 Number theoretic algorithms](#Number_theoretic_algorithms)
    *   [3.5 Numerical algorithms](#Numerical_algorithms)
        *   [3.5.1 Differential equation solving](#Differential_equation_solving)
        *   [3.5.2 Elementary and special functions](#Elementary_and_special_functions)
        *   [3.5.3 Geometric](#Geometric)
        *   [3.5.4 Interpolation and extrapolation](#Interpolation_and_extrapolation)
        *   [3.5.5 Linear algebra](#Linear_algebra)
        *   [3.5.6 Monte Carlo](#Monte_Carlo)
        *   [3.5.7 Numerical integration](#Numerical_integration)
        *   [3.5.8 Root finding](#Root_finding)
    *   [3.6 Optimization algorithms](#Optimization_algorithms)
*   [4 Computational science](#Computational_science)
    *   [4.1 Astronomy](#Astronomy)
    *   [4.2 Bioinformatics](#Bioinformatics)
    *   [4.3 Geoscience](#Geoscience)
    *   [4.4 Linguistics](#Linguistics)
    *   [4.5 Medicine](#Medicine)
    *   [4.6 Physics](#Physics)
    *   [4.7 Statistics](#Statistics)
*   [5 Computer science](#Computer_science)
    *   [5.1 Computer architecture](#Computer_architecture)
    *   [5.2 Computer graphics](#Computer_graphics)
    *   [5.3 Cryptography](#Cryptography)
    *   [5.4 Digital logic](#Digital_logic)
    *   [5.5 Machine learning and statistical classification](#Machine_learning_and_statistical_classification)
    *   [5.6 Programming language theory](#Programming_language_theory)
        *   [5.6.1 Parsing](#Parsing)
    *   [5.7 Quantum algorithms](#Quantum_algorithms)
    *   [5.8 Theory of computation and automata](#Theory_of_computation_and_automata)
*   [6 Information theory and signal processing](#Information_theory_and_signal_processing)
    *   [6.1 Coding theory](#Coding_theory)
        *   [6.1.1 Error detection and correction](#Error_detection_and_correction)
        *   [6.1.2 Lossless compression algorithms](#Lossless_compression_algorithms)
        *   [6.1.3 Lossy compression algorithms](#Lossy_compression_algorithms)
    *   [6.2 Digital signal processing](#Digital_signal_processing)
        *   [6.2.1 Image processing](#Image_processing)
*   [7 Software engineering](#Software_engineering)
*   [8 Database algorithms](#Database_algorithms)
*   [9 Distributed systems algorithms](#Distributed_systems_algorithms)
    *   [9.1 Memory allocation and deallocation algorithms](#Memory_allocation_and_deallocation_algorithms)
*   [10 Networking](#Networking)
*   [11 Operating systems algorithms](#Operating_systems_algorithms)
    *   [11.1 Process synchronization](#Process_synchronization)
    *   [11.2 Scheduling](#Scheduling)
    *   [11.3 I/O scheduling](#I/O_scheduling)
        *   [11.3.1 Disk scheduling](#Disk_scheduling)
*   [12 See also](#See_also)
*   [13 References](#References)

Automated planning\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=1 "Edit section: Automated planning")\]
----------------------------------------------------------------------------------------------------------------------------

Further information: [List of algorithms for automated planning](https://en.wikipedia.org/wiki/List_of_algorithms_for_automated_planning "List of algorithms for automated planning")

Combinatorial algorithms\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=2 "Edit section: Combinatorial algorithms")\]
----------------------------------------------------------------------------------------------------------------------------------------

Further information: [Combinatorics](https://en.wikipedia.org/wiki/Combinatorics "Combinatorics")

### General combinatorial algorithms

*   [Brent's algorithm](https://en.wikipedia.org/wiki/Cycle_detection#Brent's_algorithm "Cycle detection"): finds a cycle in function value iterations using only two iterators
*   [Floyd's cycle-finding algorithm](https://en.wikipedia.org/wiki/Floyd%27s_cycle-finding_algorithm "Floyd's cycle-finding algorithm"): finds a cycle in function value iterations
*   [Gale‚ÄìShapley algorithm](https://en.wikipedia.org/wiki/Stable_marriage_problem "Stable marriage problem"): solves the stable marriage problem
*   [Pseudorandom number generators](https://en.wikipedia.org/wiki/Pseudorandom_number_generator "Pseudorandom number generator") (uniformly distributed‚Äîsee also [List of pseudorandom number generators](https://en.wikipedia.org/wiki/List_of_random_number_generators#Pseudorandom_number_generators_(PRNGs) "List of random number generators") for other PRNGs with varying degrees of convergence and varying statistical quality):
    *   [ACORN generator](https://en.wikipedia.org/wiki/ACORN_(PRNG) "ACORN (PRNG)")
    *   [Blum Blum Shub](https://en.wikipedia.org/wiki/Blum_Blum_Shub "Blum Blum Shub")
    *   [Lagged Fibonacci generator](https://en.wikipedia.org/wiki/Lagged_Fibonacci_generator "Lagged Fibonacci generator")
    *   [Linear congruential generator](https://en.wikipedia.org/wiki/Linear_congruential_generator "Linear congruential generator")
    *   [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister "Mersenne Twister")

### Graph algorithms

Further information: [Graph theory](https://en.wikipedia.org/wiki/Graph_theory "Graph theory") and [Category:Graph algorithms](https://en.wikipedia.org/wiki/Category:Graph_algorithms "Category:Graph algorithms")

*   [Coloring algorithm](https://en.wikipedia.org/wiki/Coloring_algorithm "Coloring algorithm"): Graph coloring algorithm.
*   [Hopcroft‚ÄìKarp algorithm](https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm "Hopcroft‚ÄìKarp algorithm"): convert a bipartite graph to a [maximum cardinality matching](https://en.wikipedia.org/wiki/Maximum_cardinality_matching "Maximum cardinality matching")
*   [Hungarian algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm "Hungarian algorithm"): algorithm for finding a [perfect matching](https://en.wikipedia.org/wiki/Perfect_matching "Perfect matching")
*   [Pr√ºfer coding](https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence "Pr√ºfer sequence"): conversion between a labeled tree and its [Pr√ºfer sequence](https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence "Pr√ºfer sequence")
*   [Tarjan's off-line lowest common ancestors algorithm](https://en.wikipedia.org/wiki/Tarjan%27s_off-line_lowest_common_ancestors_algorithm "Tarjan's off-line lowest common ancestors algorithm"): compute [lowest common ancestors](https://en.wikipedia.org/wiki/Lowest_common_ancestor "Lowest common ancestor") for pairs of nodes in a tree
*   [Topological sort](https://en.wikipedia.org/wiki/Topological_sorting "Topological sorting"): finds linear order of nodes (e.g. jobs) based on their dependencies.

#### Graph drawing

Further information: [Graph drawing](https://en.wikipedia.org/wiki/Graph_drawing "Graph drawing")

*   [Force-based algorithms](https://en.wikipedia.org/wiki/Force-based_algorithms_(graph_drawing) "Force-based algorithms (graph drawing)") (also known as force-directed algorithms or spring-based algorithm)
*   [Spectral layout](https://en.wikipedia.org/wiki/Spectral_layout "Spectral layout")

#### Network theory

Further information: [Network theory](https://en.wikipedia.org/wiki/Network_theory "Network theory")

*   Network analysis
    *   Link analysis
        *   [Girvan‚ÄìNewman algorithm](https://en.wikipedia.org/wiki/Girvan%E2%80%93Newman_algorithm "Girvan‚ÄìNewman algorithm"): detect communities in complex systems
        *   Web link analysis
            *   [Hyperlink-Induced Topic Search](https://en.wikipedia.org/wiki/Hyperlink-Induced_Topic_Search "Hyperlink-Induced Topic Search") (HITS) (also known as [Hubs and authorities](https://en.wikipedia.org/wiki/Hubs_and_authorities "Hubs and authorities"))
            *   [PageRank](https://en.wikipedia.org/wiki/PageRank "PageRank")
            *   [TrustRank](https://en.wikipedia.org/wiki/TrustRank "TrustRank")
*   [Flow networks](https://en.wikipedia.org/wiki/Flow_network "Flow network")
    *   [Dinic's algorithm](https://en.wikipedia.org/wiki/Dinic%27s_algorithm "Dinic's algorithm"): is a [strongly polynomial](https://en.wikipedia.org/wiki/Strongly_polynomial "Strongly polynomial") algorithm for computing the [maximum flow](https://en.wikipedia.org/wiki/Maximum_flow "Maximum flow") in a [flow network](https://en.wikipedia.org/wiki/Flow_network "Flow network").
    *   [Edmonds‚ÄìKarp algorithm](https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm "Edmonds‚ÄìKarp algorithm"): implementation of Ford‚ÄìFulkerson
    *   [Ford‚ÄìFulkerson algorithm](https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm "Ford‚ÄìFulkerson algorithm"): computes the [maximum flow](https://en.wikipedia.org/wiki/Maximum_flow_problem "Maximum flow problem") in a graph
    *   [Karger's algorithm](https://en.wikipedia.org/wiki/Karger%27s_algorithm "Karger's algorithm"): a Monte Carlo method to compute the [minimum cut](https://en.wikipedia.org/wiki/Minimum_cut "Minimum cut") of a connected graph
    *   [Push‚Äìrelabel algorithm](https://en.wikipedia.org/wiki/Push%E2%80%93relabel_algorithm "Push‚Äìrelabel algorithm"): computes a [maximum flow](https://en.wikipedia.org/wiki/Maximum_flow_problem "Maximum flow problem") in a graph

#### Routing for graphs

*   [Edmonds' algorithm](https://en.wikipedia.org/wiki/Edmonds%27_algorithm "Edmonds' algorithm") (also known as Chu‚ÄìLiu/Edmonds' algorithm): find maximum or minimum branchings
*   [Euclidean minimum spanning tree](https://en.wikipedia.org/wiki/Euclidean_minimum_spanning_tree "Euclidean minimum spanning tree"): algorithms for computing the minimum spanning tree of a set of points in the plane
*   [Euclidean shortest path problem](https://en.wikipedia.org/wiki/Euclidean_shortest_path_problem "Euclidean shortest path problem"): find the shortest path between two points that does not intersect any obstacle
*   [Longest path problem](https://en.wikipedia.org/wiki/Longest_path_problem "Longest path problem"): find a simple path of maximum length in a given graph
*   [Minimum spanning tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree "Minimum spanning tree")
    *   [Bor≈Øvka's algorithm](https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm "Bor≈Øvka's algorithm")
    *   [Kruskal's algorithm](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm "Kruskal's algorithm")
    *   [Prim's algorithm](https://en.wikipedia.org/wiki/Prim%27s_algorithm "Prim's algorithm")
    *   [Reverse-delete algorithm](https://en.wikipedia.org/wiki/Reverse-delete_algorithm "Reverse-delete algorithm")
*   [Nonblocking minimal spanning switch](https://en.wikipedia.org/wiki/Nonblocking_minimal_spanning_switch "Nonblocking minimal spanning switch") say, for a [telephone exchange](https://en.wikipedia.org/wiki/Telephone_exchange "Telephone exchange")
*   [Shortest path problem](https://en.wikipedia.org/wiki/Shortest_path_problem "Shortest path problem")
    *   [Bellman‚ÄìFord algorithm](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm "Bellman‚ÄìFord algorithm"): computes [shortest paths](https://en.wikipedia.org/wiki/Shortest_path_problem "Shortest path problem") in a weighted graph (where some of the edge weights may be negative)
    *   [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm "Dijkstra's algorithm"): computes [shortest paths](https://en.wikipedia.org/wiki/Shortest_path_problem "Shortest path problem") in a graph with non-negative edge weights
    *   [Floyd‚ÄìWarshall algorithm](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm "Floyd‚ÄìWarshall algorithm"): solves the [all pairs shortest path](https://en.wikipedia.org/wiki/All_pairs_shortest_path "All pairs shortest path") problem in a weighted, directed graph
    *   [Johnson's algorithm](https://en.wikipedia.org/wiki/Johnson%27s_algorithm "Johnson's algorithm"): All pairs shortest path algorithm in sparse weighted directed graph
*   [Transitive closure](https://en.wikipedia.org/wiki/Transitive_closure "Transitive closure") problem: find the [transitive closure](https://en.wikipedia.org/wiki/Transitive_closure "Transitive closure") of a given binary relation
*   [Traveling salesman problem](https://en.wikipedia.org/wiki/Traveling_salesman_problem "Traveling salesman problem")
    *   [Christofides algorithm](https://en.wikipedia.org/wiki/Christofides_algorithm "Christofides algorithm")
    *   [Nearest neighbour algorithm](https://en.wikipedia.org/wiki/Nearest_neighbour_algorithm "Nearest neighbour algorithm")
*   [Warnsdorff's rule](https://en.wikipedia.org/wiki/Warnsdorff%27s_rule "Warnsdorff's rule"): A heuristic method for solving the [Knight's tour](https://en.wikipedia.org/wiki/Knight%27s_tour "Knight's tour") problem.

#### Graph search

Further information: [State space search](https://en.wikipedia.org/wiki/State_space_search "State space search") and [Graph search algorithm](https://en.wikipedia.org/wiki/Graph_search_algorithm "Graph search algorithm")

*   [A\*](https://en.wikipedia.org/wiki/A*_search_algorithm "A* search algorithm"): special case of best-first search that uses heuristics to improve speed
*   [B\*](https://en.wikipedia.org/wiki/B* "B*"): a best-first graph search algorithm that finds the least-cost path from a given initial node to any goal node (out of one or more possible goals)
*   [Backtracking](https://en.wikipedia.org/wiki/Backtracking "Backtracking"): abandons partial solutions when they are found not to satisfy a complete solution
*   [Beam search](https://en.wikipedia.org/wiki/Beam_search "Beam search"): is a heuristic search algorithm that is an optimization of [best-first search](https://en.wikipedia.org/wiki/Best-first_search "Best-first search") that reduces its memory requirement
*   [Beam stack search](https://en.wikipedia.org/wiki/Beam_stack_search "Beam stack search"): integrates backtracking with [beam search](https://en.wikipedia.org/wiki/Beam_search "Beam search")
*   [Best-first search](https://en.wikipedia.org/wiki/Best-first_search "Best-first search"): traverses a graph in the order of likely importance using a [priority queue](https://en.wikipedia.org/wiki/Priority_queue "Priority queue")
*   [Bidirectional search](https://en.wikipedia.org/wiki/Bidirectional_search "Bidirectional search"): find the shortest path from an initial vertex to a goal vertex in a directed graph
*   [Breadth-first search](https://en.wikipedia.org/wiki/Breadth-first_search "Breadth-first search"): traverses a graph level by level
*   [Brute-force search](https://en.wikipedia.org/wiki/Brute-force_search "Brute-force search"): An exhaustive and reliable search method, but computationally inefficient in many applications.
*   [D\*](https://en.wikipedia.org/wiki/D* "D*"): an [incremental heuristic search](https://en.wikipedia.org/wiki/Incremental_heuristic_search "Incremental heuristic search") algorithm
*   [Depth-first search](https://en.wikipedia.org/wiki/Depth-first_search "Depth-first search"): traverses a graph branch by branch
*   [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm "Dijkstra's algorithm"): A special case of A\* for which no heuristic function is used
*   [General Problem Solver](https://en.wikipedia.org/wiki/General_Problem_Solver "General Problem Solver"): a seminal theorem-proving algorithm intended to work as a universal problem solver machine.
*   [Iterative deepening depth-first search](https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search "Iterative deepening depth-first search") (IDDFS): a state space search strategy
*   [Jump point search](https://en.wikipedia.org/wiki/Jump_point_search "Jump point search"): An optimization to A\* which may reduce computation time by an order of magnitude using further heuristics.
*   [Lexicographic breadth-first search](https://en.wikipedia.org/wiki/Lexicographic_breadth-first_search "Lexicographic breadth-first search") (also known as Lex-BFS): a linear time algorithm for ordering the vertices of a graph
*   [Uniform-cost search](https://en.wikipedia.org/wiki/Uniform-cost_search "Uniform-cost search"): a [tree search](https://en.wikipedia.org/wiki/Tree_traversal "Tree traversal") that finds the lowest-cost route where costs vary
*   [SSS\*](https://en.wikipedia.org/wiki/SSS* "SSS*"): state space search traversing a game tree in a best-first fashion similar to that of the A\* search algorithm
*   [F\*](/w/index.php?title=F*_Merge_Algorithm&action=edit&redlink=1 "F* Merge Algorithm (page does not exist)"): Special algorithm to merge the two arrays

#### Subgraphs

*   [Cliques](https://en.wikipedia.org/wiki/Clique_(graph_theory) "Clique (graph theory)")
    *   [Bron‚ÄìKerbosch algorithm](https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm "Bron‚ÄìKerbosch algorithm"): a technique for finding [maximal cliques](https://en.wikipedia.org/wiki/Maximal_clique "Maximal clique") in an undirected graph
    *   [MaxCliqueDyn maximum clique algorithm](https://en.wikipedia.org/wiki/MaxCliqueDyn_maximum_clique_algorithm "MaxCliqueDyn maximum clique algorithm"): find a [maximum clique](https://en.wikipedia.org/wiki/Maximum_clique "Maximum clique") in an undirected graph
*   [Strongly connected components](https://en.wikipedia.org/wiki/Strongly_connected_components "Strongly connected components")
    *   [Path-based strong component algorithm](https://en.wikipedia.org/wiki/Path-based_strong_component_algorithm "Path-based strong component algorithm")
    *   [Kosaraju's algorithm](https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm "Kosaraju's algorithm")
    *   [Tarjan's strongly connected components algorithm](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm "Tarjan's strongly connected components algorithm")
*   [Subgraph isomorphism problem](https://en.wikipedia.org/wiki/Subgraph_isomorphism_problem "Subgraph isomorphism problem")

### Sequence algorithms

Further information: [Sequences](https://en.wikipedia.org/wiki/Sequences "Sequences")

#### Approximate sequence matching

*   [Bitap algorithm](https://en.wikipedia.org/wiki/Bitap_algorithm "Bitap algorithm"): fuzzy algorithm that determines if strings are approximately equal.
*   [Phonetic algorithms](https://en.wikipedia.org/wiki/Phonetic_algorithm "Phonetic algorithm")
    *   [Daitch‚ÄìMokotoff Soundex](https://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex "Daitch‚ÄìMokotoff Soundex"): a [Soundex](https://en.wikipedia.org/wiki/Soundex "Soundex") refinement which allows matching of Slavic and Germanic surnames
    *   [Double Metaphone](https://en.wikipedia.org/wiki/Double_Metaphone "Double Metaphone"): an improvement on Metaphone
    *   [Match rating approach](https://en.wikipedia.org/wiki/Match_rating_approach "Match rating approach"): a phonetic algorithm developed by Western Airlines
    *   [Metaphone](https://en.wikipedia.org/wiki/Metaphone "Metaphone"): an algorithm for indexing words by their sound, when pronounced in English
    *   [NYSIIS](https://en.wikipedia.org/wiki/New_York_State_Identification_and_Intelligence_System "New York State Identification and Intelligence System"): [phonetic algorithm](https://en.wikipedia.org/wiki/Phonetic_algorithm "Phonetic algorithm"), improves on [Soundex](https://en.wikipedia.org/wiki/Soundex "Soundex")
    *   [Soundex](https://en.wikipedia.org/wiki/Soundex "Soundex"): a phonetic algorithm for indexing names by sound, as pronounced in English
*   [String metrics](https://en.wikipedia.org/wiki/String_metric "String metric"): compute a similarity or dissimilarity (distance) score between two pairs of text strings
    *   [Damerau‚ÄìLevenshtein distance](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance "Damerau‚ÄìLevenshtein distance") compute a distance measure between two strings, improves on [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance "Levenshtein distance")
    *   [Dice's coefficient](https://en.wikipedia.org/wiki/Dice%27s_coefficient "Dice's coefficient") (also known as the Dice coefficient): a similarity measure related to the [Jaccard index](https://en.wikipedia.org/wiki/Jaccard_index "Jaccard index")
    *   [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance "Hamming distance"): sum number of positions which are different
    *   [Jaro‚ÄìWinkler distance](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance "Jaro‚ÄìWinkler distance"): is a measure of similarity between two strings
    *   [Levenshtein edit distance](https://en.wikipedia.org/wiki/Levenshtein_distance "Levenshtein distance"): compute a metric for the amount of difference between two sequences
*   [Trigram search](https://en.wikipedia.org/wiki/Trigram_search "Trigram search"): search for text when the exact syntax or spelling of the target object is not precisely known

#### Selection algorithms

Main article: [Selection algorithm](https://en.wikipedia.org/wiki/Selection_algorithm "Selection algorithm")

*   [Quickselect](https://en.wikipedia.org/wiki/Quickselect "Quickselect")
*   [Introselect](https://en.wikipedia.org/wiki/Introselect "Introselect")

#### Sequence search

*   [Linear search](https://en.wikipedia.org/wiki/Linear_search "Linear search"): finds an item in an unsorted sequence
*   [Selection algorithm](https://en.wikipedia.org/wiki/Selection_algorithm "Selection algorithm"): finds the _k_th largest item in a sequence
*   [Ternary search](https://en.wikipedia.org/wiki/Ternary_search "Ternary search"): a technique for finding the minimum or maximum of a function that is either strictly increasing and then strictly decreasing or vice versa
*   [Sorted lists](https://en.wikipedia.org/wiki/Sorted_list "Sorted list")
    *   [Binary search algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm "Binary search algorithm"): locates an item in a sorted sequence
    *   [Fibonacci search technique](https://en.wikipedia.org/wiki/Fibonacci_search_technique "Fibonacci search technique"): search a sorted sequence using a divide and conquer algorithm that narrows down possible locations with the aid of [Fibonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_numbers "Fibonacci numbers")
    *   [Jump search](https://en.wikipedia.org/wiki/Jump_search "Jump search") (or block search): linear search on a smaller subset of the sequence
    *   [Predictive search](https://en.wikipedia.org/wiki/Interpolation_search "Interpolation search"): binary-like search which factors in [magnitude](https://en.wikipedia.org/wiki/Magnitude_(mathematics) "Magnitude (mathematics)") of search term versus the high and low values in the search. Sometimes called dictionary search or interpolated search.
    *   [Uniform binary search](https://en.wikipedia.org/wiki/Uniform_binary_search "Uniform binary search"): an optimization of the classic binary search algorithm

#### Sequence merging

Main article: [Merge algorithm](https://en.wikipedia.org/wiki/Merge_algorithm "Merge algorithm")

*   Simple merge algorithm
*   k-way merge algorithm
*   Union (merge, with elements on the output not repeated)

#### Sequence permutations

Further information: [Permutation](https://en.wikipedia.org/wiki/Permutation "Permutation")

*   [Fisher‚ÄìYates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle "Fisher‚ÄìYates shuffle") (also known as the Knuth shuffle): randomly shuffle a finite set
*   [Schensted algorithm](https://en.wikipedia.org/wiki/Schensted_algorithm "Schensted algorithm"): constructs a pair of [Young tableaux](https://en.wikipedia.org/wiki/Young_tableau "Young tableau") from a permutation
*   [Steinhaus‚ÄìJohnson‚ÄìTrotter algorithm](https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm "Steinhaus‚ÄìJohnson‚ÄìTrotter algorithm") (also known as the Johnson‚ÄìTrotter algorithm): generate permutations by transposing elements
*   [Heap's permutation generation algorithm](https://en.wikipedia.org/wiki/Heap%27s_algorithm "Heap's algorithm"): interchange elements to generate next permutation

#### Sequence alignment

*   [Dynamic time warping](https://en.wikipedia.org/wiki/Dynamic_time_warping "Dynamic time warping"): measure similarity between two sequences which may vary in time or speed
*   [Hirschberg's algorithm](https://en.wikipedia.org/wiki/Hirschberg%27s_algorithm "Hirschberg's algorithm"): finds the least cost [sequence alignment](https://en.wikipedia.org/wiki/Sequence_alignment "Sequence alignment") between two sequences, as measured by their [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance "Levenshtein distance")
*   [Needleman‚ÄìWunsch algorithm](https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm "Needleman‚ÄìWunsch algorithm"): find global alignment between two sequences
*   [Smith‚ÄìWaterman algorithm](https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm "Smith‚ÄìWaterman algorithm"): find local sequence alignment

#### Sequence sorting

Main article: [Sorting algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm "Sorting algorithm")

![Accuracy dispute](//upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Ambox_contradict.svg/40px-Ambox_contradict.svg.png "Accuracy dispute")

This article **appears to contradict the article [Sorting\_algorithm#Comparison\_of\_algorithms](https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms "Sorting algorithm")**. Please see discussion on the linked [talk page](https://en.wikipedia.org/wiki/Talk:List_of_algorithms "Talk:List of algorithms"). _(March 2011)_ _([Learn how and when to remove this template message](https://en.wikipedia.org/wiki/Help:Maintenance_template_removal "Help:Maintenance template removal"))_

*   Exchange sorts
    *   [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort "Bubble sort"): for each pair of indices, swap the items if out of order
    *   [Cocktail shaker sort](https://en.wikipedia.org/wiki/Cocktail_shaker_sort "Cocktail shaker sort") or bidirectional bubble sort, a bubble sort traversing the list alternately from front to back and back to front
    *   [Comb sort](https://en.wikipedia.org/wiki/Comb_sort "Comb sort")
    *   [Gnome sort](https://en.wikipedia.org/wiki/Gnome_sort "Gnome sort")
    *   [Odd‚Äìeven sort](https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort "Odd‚Äìeven sort")
    *   [Quicksort](https://en.wikipedia.org/wiki/Quicksort "Quicksort"): divide list into two, with all items on the first list coming before all items on the second list.; then sort the two lists. Often the method of choice
*   Humorous or ineffective
    *   [Bogosort](https://en.wikipedia.org/wiki/Bogosort "Bogosort")
    *   [Stooge sort](https://en.wikipedia.org/wiki/Stooge_sort "Stooge sort")
*   Hybrid
    *   [Flashsort](https://en.wikipedia.org/wiki/Flashsort "Flashsort")
    *   [Introsort](https://en.wikipedia.org/wiki/Introsort "Introsort"): begin with quicksort and switch to heapsort when the recursion depth exceeds a certain level
    *   [Timsort](https://en.wikipedia.org/wiki/Timsort "Timsort"): adaptative algorithm derived from merge sort and insertion sort. Used in Python 2.3 and up, and Java SE 7.
*   Insertion sorts
    *   [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort "Insertion sort"): determine where the current item belongs in the list of sorted ones, and insert it there
    *   [Library sort](https://en.wikipedia.org/wiki/Library_sort "Library sort")
    *   [Patience sorting](https://en.wikipedia.org/wiki/Patience_sorting "Patience sorting")
    *   [Shell sort](https://en.wikipedia.org/wiki/Shellsort "Shellsort"): an attempt to improve insertion sort
    *   [Tree sort](https://en.wikipedia.org/wiki/Tree_sort "Tree sort") (binary tree sort): build binary tree, then traverse it to create sorted list
    *   [Cycle sort](https://en.wikipedia.org/wiki/Cycle_sort "Cycle sort"): in-place with theoretically optimal number of writes
*   Merge sorts
    *   [Merge sort](https://en.wikipedia.org/wiki/Merge_sort "Merge sort"): sort the first and second half of the list separately, then merge the sorted lists
    *   [Strand sort](https://en.wikipedia.org/wiki/Strand_sort "Strand sort")
*   Non-comparison sorts
    *   [Bead sort](https://en.wikipedia.org/wiki/Bead_sort "Bead sort")
    *   [Bucket sort](https://en.wikipedia.org/wiki/Bucket_sort "Bucket sort")
    *   [Burstsort](https://en.wikipedia.org/wiki/Burstsort "Burstsort"): build a compact, cache efficient [burst trie](/w/index.php?title=Burst_trie&action=edit&redlink=1 "Burst trie (page does not exist)") and then traverse it to create sorted output
    *   [Counting sort](https://en.wikipedia.org/wiki/Counting_sort "Counting sort")
    *   [Pigeonhole sort](https://en.wikipedia.org/wiki/Pigeonhole_sort "Pigeonhole sort")
    *   [Postman sort](https://en.wikipedia.org/wiki/Postman_sort "Postman sort"): variant of Bucket sort which takes advantage of hierarchical structure
    *   [Radix sort](https://en.wikipedia.org/wiki/Radix_sort "Radix sort"): sorts strings letter by letter
*   Selection sorts
    *   [Heapsort](https://en.wikipedia.org/wiki/Heapsort "Heapsort"): convert the list into a heap, keep removing the largest element from the heap and adding it to the end of the list
    *   [Selection sort](https://en.wikipedia.org/wiki/Selection_sort "Selection sort"): pick the smallest of the remaining elements, add it to the end of the sorted list
    *   [Smoothsort](https://en.wikipedia.org/wiki/Smoothsort "Smoothsort")
*   Other
    *   [Bitonic sorter](https://en.wikipedia.org/wiki/Bitonic_sorter "Bitonic sorter")
    *   [Pancake sorting](https://en.wikipedia.org/wiki/Pancake_sorting "Pancake sorting")
    *   [Spaghetti sort](https://en.wikipedia.org/wiki/Spaghetti_sort "Spaghetti sort")
    *   [Topological sort](https://en.wikipedia.org/wiki/Topological_sorting "Topological sorting")
*   Unknown class
    *   [Samplesort](https://en.wikipedia.org/wiki/Samplesort "Samplesort")

#### Subsequences

Further information: [Subsequence](https://en.wikipedia.org/wiki/Subsequence "Subsequence")

*   [Kadane's algorithm](https://en.wikipedia.org/wiki/Kadane%27s_algorithm "Kadane's algorithm"): finds maximum sub-array of any size
*   [Longest common subsequence problem](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem "Longest common subsequence problem"): Find the longest subsequence common to all sequences in a set of sequences
*   [Longest increasing subsequence problem](https://en.wikipedia.org/wiki/Longest_increasing_subsequence_problem "Longest increasing subsequence problem"): Find the longest increasing subsequence of a given sequence
*   [Shortest common supersequence problem](https://en.wikipedia.org/wiki/Shortest_common_supersequence_problem "Shortest common supersequence problem"): Find the shortest supersequence that contains two or more sequences as subsequences

#### Substrings

Further information: [Substring](https://en.wikipedia.org/wiki/Substring "Substring")

*   [Longest common substring problem](https://en.wikipedia.org/wiki/Longest_common_substring_problem "Longest common substring problem"): find the longest string (or strings) that is a substring (or are substrings) of two or more strings
*   [Substring search](https://en.wikipedia.org/wiki/Substring_search "Substring search")
    *   [Aho‚ÄìCorasick string matching algorithm](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm "Aho‚ÄìCorasick string matching algorithm"): [trie](https://en.wikipedia.org/wiki/Trie "Trie") based algorithm for finding all substring matches to any of a finite set of strings
    *   [Boyer‚ÄìMoore string-search algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm "Boyer‚ÄìMoore string-search algorithm"): amortized linear ([sublinear](https://en.wikipedia.org/wiki/Sublinear "Sublinear") in most times) algorithm for substring search
    *   [Boyer‚ÄìMoore‚ÄìHorspool algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm "Boyer‚ÄìMoore‚ÄìHorspool algorithm"): Simplification of Boyer‚ÄìMoore
    *   [Knuth‚ÄìMorris‚ÄìPratt algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm "Knuth‚ÄìMorris‚ÄìPratt algorithm"): substring search which bypasses reexamination of matched characters
    *   [Rabin‚ÄìKarp string search algorithm](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_string_search_algorithm "Rabin‚ÄìKarp string search algorithm"): searches multiple patterns efficiently
    *   [Zhu‚ÄìTakaoka string matching algorithm](https://en.wikipedia.org/wiki/Zhu%E2%80%93Takaoka_string_matching_algorithm "Zhu‚ÄìTakaoka string matching algorithm"): a variant of Boyer‚ÄìMoore
*   [Ukkonen's algorithm](https://en.wikipedia.org/wiki/Ukkonen%27s_algorithm "Ukkonen's algorithm"): a [linear-time](https://en.wikipedia.org/wiki/Linear-time "Linear-time"), [online algorithm](https://en.wikipedia.org/wiki/Online_algorithm "Online algorithm") for constructing [suffix trees](https://en.wikipedia.org/wiki/Suffix_tree "Suffix tree")
*   [Matching wildcards](https://en.wikipedia.org/wiki/Matching_wildcards "Matching wildcards")
    *   [Rich Salz](https://en.wikipedia.org/wiki/InterNetNews "InterNetNews")' [wildmat](https://en.wikipedia.org/wiki/Wildmat "Wildmat"): a widely used [open-source](https://en.wikipedia.org/wiki/Open-source_software "Open-source software") [recursive](https://en.wikipedia.org/wiki/Recursion "Recursion") algorithm
    *   [Krauss matching wildcards algorithm](https://en.wikipedia.org/wiki/Krauss_matching_wildcards_algorithm "Krauss matching wildcards algorithm"): an open-source non-recursive algorithm

Computational mathematics\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=20 "Edit section: Computational mathematics")\]
-------------------------------------------------------------------------------------------------------------------------------------------

Further information: [Computational mathematics](https://en.wikipedia.org/wiki/Computational_mathematics "Computational mathematics")

See also: [Combinatorial algorithms](https://en.wikipedia.org/wiki/List_of_algorithms#Combinatorial_algorithms "List of algorithms") and [Computational science](https://en.wikipedia.org/wiki/List_of_algorithms#Computational_science "List of algorithms")

### Abstract algebra

Further information: [Abstract algebra](https://en.wikipedia.org/wiki/Abstract_algebra "Abstract algebra")

*   [Chien search](https://en.wikipedia.org/wiki/Chien_search "Chien search"): a recursive algorithm for determining roots of polynomials defined over a finite field
*   [Schreier‚ÄìSims algorithm](https://en.wikipedia.org/wiki/Schreier%E2%80%93Sims_algorithm "Schreier‚ÄìSims algorithm"): computing a base and [strong generating set](https://en.wikipedia.org/wiki/Strong_generating_set "Strong generating set") (BSGS) of a [permutation group](https://en.wikipedia.org/wiki/Permutation_group "Permutation group")
*   [Todd‚ÄìCoxeter algorithm](https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm "Todd‚ÄìCoxeter algorithm"): Procedure for generating [cosets](https://en.wikipedia.org/wiki/Coset "Coset").

### Computer algebra

Further information: [Computer algebra](https://en.wikipedia.org/wiki/Computer_algebra "Computer algebra")

*   [Buchberger's algorithm](https://en.wikipedia.org/wiki/Buchberger%27s_algorithm "Buchberger's algorithm"): finds a [Gr√∂bner basis](https://en.wikipedia.org/wiki/Gr%C3%B6bner_basis "Gr√∂bner basis")
*   [Cantor‚ÄìZassenhaus algorithm](https://en.wikipedia.org/wiki/Cantor%E2%80%93Zassenhaus_algorithm "Cantor‚ÄìZassenhaus algorithm"): factor polynomials over finite fields
*   [Faug√®re F4 algorithm](https://en.wikipedia.org/wiki/Faug%C3%A8re_F4_algorithm "Faug√®re F4 algorithm"): finds a Gr√∂bner basis (also mentions the F5 algorithm)
*   [Gosper's algorithm](https://en.wikipedia.org/wiki/Gosper%27s_algorithm "Gosper's algorithm"): find sums of hypergeometric terms that are themselves hypergeometric terms
*   [Knuth‚ÄìBendix completion algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm "Knuth‚ÄìBendix completion algorithm"): for [rewriting](https://en.wikipedia.org/wiki/Rewriting "Rewriting") rule systems
*   [Multivariate division algorithm](https://en.wikipedia.org/wiki/Multivariate_division_algorithm "Multivariate division algorithm"): for [polynomials](https://en.wikipedia.org/wiki/Polynomial "Polynomial") in several indeterminates
*   [Pollard's kangaroo algorithm](https://en.wikipedia.org/wiki/Pollard%27s_kangaroo_algorithm "Pollard's kangaroo algorithm") (also known as Pollard's lambda algorithm ): an algorithm for solving the discrete logarithm problem
*   [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division "Polynomial long division"): an algorithm for dividing a polynomial by another polynomial of the same or lower degree
*   [Risch algorithm](https://en.wikipedia.org/wiki/Risch_algorithm "Risch algorithm"): an algorithm for the calculus operation of indefinite integration (i.e. finding [antiderivatives](https://en.wikipedia.org/wiki/Antiderivatives "Antiderivatives"))

### Geometry

Main category: [Geometric algorithms](https://en.wikipedia.org/wiki/Category:Geometric_algorithms "Category:Geometric algorithms")

Further information: [Computational geometry](https://en.wikipedia.org/wiki/Computational_geometry "Computational geometry")

*   [Closest pair problem](https://en.wikipedia.org/wiki/Closest_pair_problem "Closest pair problem"): find the pair of points (from a set of points) with the smallest distance between them
*   [Collision detection](https://en.wikipedia.org/wiki/Collision_detection "Collision detection") algorithms: check for the collision or intersection of two given solids
*   [Cone algorithm](https://en.wikipedia.org/wiki/Cone_algorithm "Cone algorithm"): identify surface points
*   [Convex hull algorithms](https://en.wikipedia.org/wiki/Convex_hull_algorithms "Convex hull algorithms"): determining the [convex hull](https://en.wikipedia.org/wiki/Convex_hull "Convex hull") of a [set](https://en.wikipedia.org/wiki/Set_(mathematics) "Set (mathematics)") of points
    *   [Graham scan](https://en.wikipedia.org/wiki/Graham_scan "Graham scan")
    *   [Quickhull](https://en.wikipedia.org/wiki/Quickhull "Quickhull")
    *   [Gift wrapping algorithm](https://en.wikipedia.org/wiki/Gift_wrapping_algorithm "Gift wrapping algorithm") or Jarvis march
    *   [Chan's algorithm](https://en.wikipedia.org/wiki/Chan%27s_algorithm "Chan's algorithm")
    *   [Kirkpatrick‚ÄìSeidel algorithm](https://en.wikipedia.org/wiki/Kirkpatrick%E2%80%93Seidel_algorithm "Kirkpatrick‚ÄìSeidel algorithm")
*   [Euclidean distance transform](https://en.wikipedia.org/wiki/Euclidean_distance_map "Euclidean distance map"): computes the distance between every point in a grid and a discrete collection of points.
*   [Geometric hashing](https://en.wikipedia.org/wiki/Geometric_hashing "Geometric hashing"): a method for efficiently finding two-dimensional objects represented by discrete points that have undergone an [affine transformation](https://en.wikipedia.org/wiki/Affine_transformation "Affine transformation")
*   [Gilbert‚ÄìJohnson‚ÄìKeerthi distance algorithm](https://en.wikipedia.org/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm "Gilbert‚ÄìJohnson‚ÄìKeerthi distance algorithm"): determining the smallest distance between two [convex](https://en.wikipedia.org/wiki/Convex_set "Convex set") shapes.
*   [Jump-and-Walk algorithm](https://en.wikipedia.org/wiki/Jump-and-Walk_algorithm "Jump-and-Walk algorithm"): an algorithm for point location in triangulations
*   [Laplacian smoothing](https://en.wikipedia.org/wiki/Laplacian_smoothing "Laplacian smoothing"): an algorithm to smooth a polygonal mesh
*   [Line segment intersection](https://en.wikipedia.org/wiki/Line_segment_intersection "Line segment intersection"): finding whether lines intersect, usually with a [sweep line algorithm](https://en.wikipedia.org/wiki/Sweep_line_algorithm "Sweep line algorithm")
    *   [Bentley‚ÄìOttmann algorithm](https://en.wikipedia.org/wiki/Bentley%E2%80%93Ottmann_algorithm "Bentley‚ÄìOttmann algorithm")
    *   [Shamos‚ÄìHoey algorithm](/w/index.php?title=Shamos%E2%80%93Hoey_algorithm&action=edit&redlink=1 "Shamos‚ÄìHoey algorithm (page does not exist)")
*   [Minimum bounding box algorithms](https://en.wikipedia.org/wiki/Minimum_bounding_box_algorithms "Minimum bounding box algorithms"): find the [oriented minimum bounding box](https://en.wikipedia.org/wiki/Minimum_bounding_box#Arbitrarily_oriented_minimum_bounding_box "Minimum bounding box") enclosing a set of points
*   [Nearest neighbor search](https://en.wikipedia.org/wiki/Nearest_neighbor_search "Nearest neighbor search"): find the nearest point or points to a query point
*   [Point in polygon](https://en.wikipedia.org/wiki/Point_in_polygon "Point in polygon") algorithms: tests whether a given point lies within a given polygon
*   [Point set registration](https://en.wikipedia.org/wiki/Point_set_registration "Point set registration") algorithms: finds the transformation between two [point sets](https://en.wikipedia.org/wiki/Point_cloud "Point cloud") to optimally align them.
*   [Rotating calipers](https://en.wikipedia.org/wiki/Rotating_calipers "Rotating calipers"): determine all [antipodal](https://en.wikipedia.org/wiki/Antipodal_point "Antipodal point") pairs of points and vertices on a [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon "Convex polygon") or [convex hull](https://en.wikipedia.org/wiki/Convex_hull "Convex hull").
*   [Shoelace algorithm](https://en.wikipedia.org/wiki/Shoelace_algorithm "Shoelace algorithm"): determine the area of a polygon whose vertices are described by ordered pairs in the plane
*   [Triangulation](https://en.wikipedia.org/wiki/Triangulation_(geometry) "Triangulation (geometry)")
    *   [Delaunay triangulation](https://en.wikipedia.org/wiki/Delaunay_triangulation "Delaunay triangulation")
        *   [Ruppert's algorithm](https://en.wikipedia.org/wiki/Ruppert%27s_algorithm "Ruppert's algorithm") (also known as Delaunay refinement): create quality Delaunay triangulations
        *   [Chew's second algorithm](https://en.wikipedia.org/wiki/Chew%27s_second_algorithm "Chew's second algorithm"): create quality [constrained Delaunay triangulations](https://en.wikipedia.org/wiki/Constrained_Delaunay_triangulation "Constrained Delaunay triangulation")
    *   [Marching triangles](https://en.wikipedia.org/wiki/Marching_triangles "Marching triangles"): reconstruct two-dimensional surface geometry from an unstructured [point cloud](https://en.wikipedia.org/wiki/Point_cloud "Point cloud")
    *   [Polygon triangulation](https://en.wikipedia.org/wiki/Polygon_triangulation "Polygon triangulation") algorithms: decompose a polygon into a set of triangles
    *   [Voronoi diagrams](https://en.wikipedia.org/wiki/Voronoi_diagram "Voronoi diagram"), geometric [dual](https://en.wikipedia.org/wiki/Duality_(mathematics) "Duality (mathematics)") of [Delaunay triangulation](https://en.wikipedia.org/wiki/Delaunay_triangulation "Delaunay triangulation")
        *   [Bowyer‚ÄìWatson algorithm](https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm "Bowyer‚ÄìWatson algorithm"): create voronoi diagram in any number of dimensions
        *   [Fortune's Algorithm](https://en.wikipedia.org/wiki/Fortune%27s_Algorithm "Fortune's Algorithm"): create voronoi diagram
    *   [Quasitriangulation](https://en.wikipedia.org/wiki/Quasitriangulation "Quasitriangulation")

### Number theoretic algorithms

Further information: [Number theory](https://en.wikipedia.org/wiki/Number_theory "Number theory")

*   [Binary GCD algorithm](https://en.wikipedia.org/wiki/Binary_GCD_algorithm "Binary GCD algorithm"): Efficient way of calculating GCD.
*   [Booth's multiplication algorithm](https://en.wikipedia.org/wiki/Booth%27s_multiplication_algorithm "Booth's multiplication algorithm")
*   [Chakravala method](https://en.wikipedia.org/wiki/Chakravala_method "Chakravala method"): a cyclic algorithm to solve indeterminate quadratic equations, including [Pell's equation](https://en.wikipedia.org/wiki/Pell%27s_equation "Pell's equation")
*   [Discrete logarithm](https://en.wikipedia.org/wiki/Discrete_logarithm "Discrete logarithm"):
    *   [Baby-step giant-step](https://en.wikipedia.org/wiki/Baby-step_giant-step "Baby-step giant-step")
    *   [Index calculus algorithm](https://en.wikipedia.org/wiki/Index_calculus_algorithm "Index calculus algorithm")
    *   [Pollard's rho algorithm for logarithms](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms "Pollard's rho algorithm for logarithms")
    *   [Pohlig‚ÄìHellman algorithm](https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm "Pohlig‚ÄìHellman algorithm")
*   [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm "Euclidean algorithm"): computes the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor "Greatest common divisor")
*   [Extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm "Extended Euclidean algorithm"): Also solves the equation _ax_¬†+¬†_by_¬†=¬†_c_.
*   [Integer factorization](https://en.wikipedia.org/wiki/Integer_factorization "Integer factorization"): breaking an integer into its [prime](https://en.wikipedia.org/wiki/Prime_number "Prime number") factors
    *   [Congruence of squares](https://en.wikipedia.org/wiki/Congruence_of_squares "Congruence of squares")
    *   [Dixon's algorithm](https://en.wikipedia.org/wiki/Dixon%27s_algorithm "Dixon's algorithm")
    *   [Fermat's factorization method](https://en.wikipedia.org/wiki/Fermat%27s_factorization_method "Fermat's factorization method")
    *   [General number field sieve](https://en.wikipedia.org/wiki/General_number_field_sieve "General number field sieve")
    *   [Lenstra elliptic curve factorization](https://en.wikipedia.org/wiki/Lenstra_elliptic_curve_factorization "Lenstra elliptic curve factorization")
    *   [Pollard's _p_¬†‚àí¬†1 algorithm](https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm "Pollard's p ‚àí 1 algorithm")
    *   [Pollard's rho algorithm](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm "Pollard's rho algorithm")
    *   [prime factorization algorithm](https://en.wikipedia.org/wiki/Prime_factorization_algorithm "Prime factorization algorithm")
    *   [Quadratic sieve](https://en.wikipedia.org/wiki/Quadratic_sieve "Quadratic sieve")
    *   [Shor's algorithm](https://en.wikipedia.org/wiki/Shor%27s_algorithm "Shor's algorithm")
    *   [Special number field sieve](https://en.wikipedia.org/wiki/Special_number_field_sieve "Special number field sieve")
    *   [Trial division](https://en.wikipedia.org/wiki/Trial_division "Trial division")
*   [Multiplication algorithms](https://en.wikipedia.org/wiki/Multiplication_algorithm "Multiplication algorithm"): fast multiplication of two numbers
    *   [Karatsuba algorithm](https://en.wikipedia.org/wiki/Karatsuba_algorithm "Karatsuba algorithm")
    *   [Sch√∂nhage‚ÄìStrassen algorithm](https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm "Sch√∂nhage‚ÄìStrassen algorithm")
    *   [Toom‚ÄìCook multiplication](https://en.wikipedia.org/wiki/Toom%E2%80%93Cook_multiplication "Toom‚ÄìCook multiplication")
*   [Modular square root](https://en.wikipedia.org/wiki/Modular_square_root "Modular square root"): computing square roots modulo a prime number
    *   [Tonelli‚ÄìShanks algorithm](https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm "Tonelli‚ÄìShanks algorithm")
    *   [Cipolla's algorithm](https://en.wikipedia.org/wiki/Cipolla%27s_algorithm "Cipolla's algorithm")
    *   [Berlekamp's root finding algorithm](https://en.wikipedia.org/wiki/Berlekamp%27s_root_finding_algorithm "Berlekamp's root finding algorithm")
*   [Odlyzko‚ÄìSch√∂nhage algorithm](https://en.wikipedia.org/wiki/Odlyzko%E2%80%93Sch%C3%B6nhage_algorithm "Odlyzko‚ÄìSch√∂nhage algorithm"): calculates nontrivial zeroes of the [Riemann zeta function](https://en.wikipedia.org/wiki/Riemann_zeta_function "Riemann zeta function")
*   [Lenstra‚ÄìLenstra‚ÄìLov√°sz algorithm](https://en.wikipedia.org/wiki/Lenstra%E2%80%93Lenstra%E2%80%93Lov%C3%A1sz_lattice_basis_reduction_algorithm "Lenstra‚ÄìLenstra‚ÄìLov√°sz lattice basis reduction algorithm") (also known as LLL algorithm): find a short, nearly orthogonal [lattice](https://en.wikipedia.org/wiki/Lattice_(group) "Lattice (group)") [basis](https://en.wikipedia.org/wiki/Basis_(linear_algebra) "Basis (linear algebra)") in polynomial time
*   [Primality tests](https://en.wikipedia.org/wiki/Primality_test "Primality test"): determining whether a given number is [prime](https://en.wikipedia.org/wiki/Prime_number "Prime number")
    *   [AKS primality test](https://en.wikipedia.org/wiki/AKS_primality_test "AKS primality test")
    *   [Baillie-PSW primality test](https://en.wikipedia.org/wiki/Baillie-PSW_primality_test "Baillie-PSW primality test")
    *   [Fermat primality test](https://en.wikipedia.org/wiki/Fermat_primality_test "Fermat primality test")
    *   [Lucas primality test](https://en.wikipedia.org/wiki/Lucas_primality_test "Lucas primality test")
    *   [Miller‚ÄìRabin primality test](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test "Miller‚ÄìRabin primality test")
    *   [Sieve of Atkin](https://en.wikipedia.org/wiki/Sieve_of_Atkin "Sieve of Atkin")
    *   [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes "Sieve of Eratosthenes")
    *   [Sieve of Sundaram](https://en.wikipedia.org/wiki/Sieve_of_Sundaram "Sieve of Sundaram")

### Numerical algorithms

Further information: [Numerical analysis](https://en.wikipedia.org/wiki/Numerical_analysis "Numerical analysis") and [List of numerical analysis topics](https://en.wikipedia.org/wiki/List_of_numerical_analysis_topics "List of numerical analysis topics")

#### Differential equation solving

Further information: [Differential equation](https://en.wikipedia.org/wiki/Differential_equation "Differential equation")

*   [Euler method](https://en.wikipedia.org/wiki/Euler_method "Euler method")
*   [Backward Euler method](https://en.wikipedia.org/wiki/Backward_Euler_method "Backward Euler method")
*   [Trapezoidal rule (differential equations)](https://en.wikipedia.org/wiki/Trapezoidal_rule_(differential_equations) "Trapezoidal rule (differential equations)")
*   [Linear multistep methods](https://en.wikipedia.org/wiki/Linear_multistep_method "Linear multistep method")
*   [Runge‚ÄìKutta methods](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods "Runge‚ÄìKutta methods")
    *   [Euler integration](https://en.wikipedia.org/wiki/Euler_integration "Euler integration")
*   [Multigrid methods](https://en.wikipedia.org/wiki/Multigrid_method "Multigrid method") (MG methods), a group of algorithms for solving differential equations using a hierarchy of discretizations
*   [Partial differential equation](https://en.wikipedia.org/wiki/Partial_differential_equation "Partial differential equation"):
    *   [Finite difference method](https://en.wikipedia.org/wiki/Finite_difference_method "Finite difference method")
    *   [Crank‚ÄìNicolson method](https://en.wikipedia.org/wiki/Crank%E2%80%93Nicolson_method "Crank‚ÄìNicolson method") for diffusion equations
    *   [Lax-Wendroff](https://en.wikipedia.org/wiki/Lax%E2%80%93Wendroff_method "Lax‚ÄìWendroff method") for wave equations
*   [Verlet integration](https://en.wikipedia.org/wiki/Verlet_integration "Verlet integration") (French pronunciation:¬†‚Äã[\[v…õ ÅÀàl…õ\]](https://en.wikipedia.org/wiki/Help:IPA/French "Help:IPA/French")): integrate Newton's equations of motion

#### Elementary and special functions

Further information: [Special functions](https://en.wikipedia.org/wiki/Special_functions "Special functions")

*   [Computation of œÄ](https://en.wikipedia.org/wiki/Computing_%CF%80 "Computing œÄ"):
    *   [Borwein's algorithm](https://en.wikipedia.org/wiki/Borwein%27s_algorithm "Borwein's algorithm"): an algorithm to calculate the value of 1/œÄ
    *   [Gauss‚ÄìLegendre algorithm](https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_algorithm "Gauss‚ÄìLegendre algorithm"): computes the digits of [pi](https://en.wikipedia.org/wiki/Pi "Pi")
    *   [Chudnovsky algorithm](https://en.wikipedia.org/wiki/Chudnovsky_algorithm "Chudnovsky algorithm"): A fast method for calculating the digits of œÄ
    *   [Bailey‚ÄìBorwein‚ÄìPlouffe formula](https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula "Bailey‚ÄìBorwein‚ÄìPlouffe formula"): (BBP formula) a spigot algorithm for the computation of the nth binary digit of œÄ
*   [Division algorithms](https://en.wikipedia.org/wiki/Division_algorithm "Division algorithm"): for computing quotient and/or remainder of two numbers
    *   [Long division](https://en.wikipedia.org/wiki/Long_division "Long division")
    *   [Restoring division](https://en.wikipedia.org/wiki/Restoring_division "Restoring division")
    *   [Non-restoring division](https://en.wikipedia.org/wiki/Non-restoring_division "Non-restoring division")
    *   [SRT division](https://en.wikipedia.org/wiki/SRT_division "SRT division")
    *   [Newton‚ÄìRaphson division](https://en.wikipedia.org/wiki/Newton%E2%80%93Raphson_division "Newton‚ÄìRaphson division"): uses [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method "Newton's method") to find the [reciprocal](https://en.wikipedia.org/wiki/Multiplicative_inverse "Multiplicative inverse") of D, and multiply that reciprocal by N to find the final quotient Q.
    *   [Goldschmidt division](https://en.wikipedia.org/wiki/Goldschmidt_division "Goldschmidt division")
*   Hyperbolic and Trigonometric Functions:
    *   [BKM algorithm](https://en.wikipedia.org/wiki/BKM_algorithm "BKM algorithm"): compute [elementary functions](https://en.wikipedia.org/wiki/Elementary_function_(differential_algebra) "Elementary function (differential algebra)") using a table of logarithms
    *   [CORDIC](https://en.wikipedia.org/wiki/CORDIC "CORDIC"): compute hyperbolic and trigonometric functions using a table of arctangents
*   Exponentiation:
    *   [Addition-chain exponentiation](https://en.wikipedia.org/wiki/Addition-chain_exponentiation "Addition-chain exponentiation"): exponentiation by positive integer powers that requires a minimal number of multiplications
    *   [Exponentiating by squaring](https://en.wikipedia.org/wiki/Exponentiating_by_squaring "Exponentiating by squaring"): an algorithm used for the fast computation of [large integer](https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic "Arbitrary-precision arithmetic") powers of a number
*   [Montgomery reduction](https://en.wikipedia.org/wiki/Montgomery_reduction "Montgomery reduction"): an algorithm that allows [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic "Modular arithmetic") to be performed efficiently when the modulus is large
*   [Multiplication algorithms](https://en.wikipedia.org/wiki/Multiplication_algorithm "Multiplication algorithm"): fast multiplication of two numbers
    *   [Booth's multiplication algorithm](https://en.wikipedia.org/wiki/Booth%27s_multiplication_algorithm "Booth's multiplication algorithm"): a multiplication algorithm that multiplies two signed binary numbers in two's complement notation
    *   [F√ºrer's algorithm](https://en.wikipedia.org/wiki/F%C3%BCrer%27s_algorithm "F√ºrer's algorithm"): an integer multiplication algorithm for very large numbers possessing a very low [asymptotic complexity](https://en.wikipedia.org/wiki/Computational_complexity_theory "Computational complexity theory")
    *   [Karatsuba algorithm](https://en.wikipedia.org/wiki/Karatsuba_algorithm "Karatsuba algorithm"): an efficient procedure for multiplying large numbers
    *   [Sch√∂nhage‚ÄìStrassen algorithm](https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm "Sch√∂nhage‚ÄìStrassen algorithm"): an asymptotically fast multiplication algorithm for large integers
    *   [Toom‚ÄìCook multiplication](https://en.wikipedia.org/wiki/Toom%E2%80%93Cook_multiplication "Toom‚ÄìCook multiplication"): (Toom3) a multiplication algorithm for large integers
*   [Multiplicative inverse Algorithms](https://en.wikipedia.org/wiki/Multiplicative_inverse#Algorithms "Multiplicative inverse"): for computing a number's multiplicative inverse (reciprocal).
    *   [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method#Multiplicative_inverses_of_numbers_and_power_series "Newton's method")
*   [Rounding functions](https://en.wikipedia.org/wiki/Rounding_functions "Rounding functions"): the classic ways to round numbers
*   [Spigot algorithm](https://en.wikipedia.org/wiki/Spigot_algorithm "Spigot algorithm"): A way to compute the value of a [mathematical constant](https://en.wikipedia.org/wiki/Mathematical_constant "Mathematical constant") without knowing preceding digits
*   Square and Nth root of a number:
    *   [Alpha max plus beta min algorithm](https://en.wikipedia.org/wiki/Alpha_max_plus_beta_min_algorithm "Alpha max plus beta min algorithm"): an approximation of the square-root of the sum of two squares
    *   [Methods of computing square roots](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots "Methods of computing square roots")
    *   [_n_th root algorithm](https://en.wikipedia.org/wiki/Nth_root_algorithm "Nth root algorithm")
    *   [Shifting nth-root algorithm](https://en.wikipedia.org/wiki/Shifting_nth-root_algorithm "Shifting nth-root algorithm"): digit by digit root extraction
*   Summation:
    *   [Binary splitting](https://en.wikipedia.org/wiki/Binary_splitting "Binary splitting"): a [divide and conquer](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm "Divide and conquer algorithm") technique which speeds up the numerical evaluation of many types of series with rational terms
    *   [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm "Kahan summation algorithm"): a more accurate method of summing floating-point numbers
*   [Unrestricted algorithm](https://en.wikipedia.org/wiki/Unrestricted_algorithm "Unrestricted algorithm")

#### Geometric

*   [Filtered back-projection](https://en.wikipedia.org/wiki/Radon_transform#Filtered_back-projection "Radon transform"): efficiently compute the inverse 2-dimensional [Radon transform](https://en.wikipedia.org/wiki/Radon_transform "Radon transform").
*   [Level set method](https://en.wikipedia.org/wiki/Level_set_method "Level set method") (LSM): a numerical technique for tracking interfaces and shapes

#### Interpolation and extrapolation

Further information: [Interpolation](https://en.wikipedia.org/wiki/Interpolation "Interpolation") and [Extrapolation](https://en.wikipedia.org/wiki/Extrapolation "Extrapolation")

*   [Birkhoff interpolation](https://en.wikipedia.org/wiki/Birkhoff_interpolation "Birkhoff interpolation"): an extension of polynomial interpolation
*   [Cubic interpolation](https://en.wikipedia.org/wiki/Cubic_interpolation "Cubic interpolation")
*   [Hermite interpolation](https://en.wikipedia.org/wiki/Hermite_interpolation "Hermite interpolation")
*   [Lagrange interpolation](https://en.wikipedia.org/wiki/Lagrange_interpolation "Lagrange interpolation"): interpolation using [Lagrange polynomials](https://en.wikipedia.org/wiki/Lagrange_polynomial "Lagrange polynomial")
*   [Linear interpolation](https://en.wikipedia.org/wiki/Linear_interpolation "Linear interpolation"): a method of curve fitting using linear polynomials
*   [Monotone cubic interpolation](https://en.wikipedia.org/wiki/Monotone_cubic_interpolation "Monotone cubic interpolation"): a variant of cubic interpolation that preserves monotonicity of the data set being interpolated.
*   [Multivariate interpolation](https://en.wikipedia.org/wiki/Multivariate_interpolation "Multivariate interpolation")
    *   [Bicubic interpolation](https://en.wikipedia.org/wiki/Bicubic_interpolation "Bicubic interpolation"), a generalization of [cubic interpolation](https://en.wikipedia.org/wiki/Cubic_interpolation "Cubic interpolation") to two dimensions
    *   [Bilinear interpolation](https://en.wikipedia.org/wiki/Bilinear_interpolation "Bilinear interpolation"): an extension of [linear interpolation](https://en.wikipedia.org/wiki/Linear_interpolation "Linear interpolation") for interpolating functions of two variables on a regular grid
    *   [Lanczos resampling](https://en.wikipedia.org/wiki/Lanczos_resampling "Lanczos resampling") ("Lanzosh"): a multivariate interpolation method used to compute new values for any digitally sampled data
    *   [Nearest-neighbor interpolation](https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation "Nearest-neighbor interpolation")
    *   [Tricubic interpolation](https://en.wikipedia.org/wiki/Tricubic_interpolation "Tricubic interpolation"), a generalization of [cubic interpolation](https://en.wikipedia.org/wiki/Cubic_interpolation "Cubic interpolation") to three dimensions
*   [Pareto interpolation](https://en.wikipedia.org/wiki/Pareto_interpolation "Pareto interpolation"): a method of estimating the median and other properties of a population that follows a [Pareto distribution](https://en.wikipedia.org/wiki/Pareto_distribution "Pareto distribution").
*   [Polynomial interpolation](https://en.wikipedia.org/wiki/Polynomial_interpolation "Polynomial interpolation")
    *   [Neville's algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm "Neville's algorithm")
*   [Spline interpolation](https://en.wikipedia.org/wiki/Spline_interpolation "Spline interpolation"): Reduces error with [Runge's phenomenon](https://en.wikipedia.org/wiki/Runge%27s_phenomenon "Runge's phenomenon").
    *   [De Boor algorithm](https://en.wikipedia.org/wiki/De_Boor_algorithm "De Boor algorithm"): [B-splines](https://en.wikipedia.org/wiki/B-spline "B-spline")
    *   [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm "De Casteljau's algorithm"): [B√©zier curves](https://en.wikipedia.org/wiki/B%C3%A9zier_curve "B√©zier curve")
*   [Trigonometric interpolation](https://en.wikipedia.org/wiki/Trigonometric_interpolation "Trigonometric interpolation")

#### Linear algebra

Further information: [Numerical linear algebra](https://en.wikipedia.org/wiki/Numerical_linear_algebra "Numerical linear algebra")

*   [Eigenvalue algorithms](https://en.wikipedia.org/wiki/Eigenvalue_algorithm "Eigenvalue algorithm")
    *   [Arnoldi iteration](https://en.wikipedia.org/wiki/Arnoldi_iteration "Arnoldi iteration")
    *   [Inverse iteration](https://en.wikipedia.org/wiki/Inverse_iteration "Inverse iteration")
    *   [Jacobi method](https://en.wikipedia.org/wiki/Jacobi_eigenvalue_algorithm "Jacobi eigenvalue algorithm")
    *   [Lanczos iteration](https://en.wikipedia.org/wiki/Lanczos_iteration "Lanczos iteration")
    *   [Power iteration](https://en.wikipedia.org/wiki/Power_iteration "Power iteration")
    *   [QR algorithm](https://en.wikipedia.org/wiki/QR_algorithm "QR algorithm")
    *   [Rayleigh quotient iteration](https://en.wikipedia.org/wiki/Rayleigh_quotient_iteration "Rayleigh quotient iteration")
*   [Gram‚ÄìSchmidt process](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process "Gram‚ÄìSchmidt process"): orthogonalizes a set of vectors
*   [Matrix multiplication algorithms](https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm "Matrix multiplication algorithm")
    *   [Cannon's algorithm](https://en.wikipedia.org/wiki/Cannon%27s_algorithm "Cannon's algorithm"): a [distributed algorithm](https://en.wikipedia.org/wiki/Distributed_algorithm "Distributed algorithm") for [matrix multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication "Matrix multiplication") especially suitable for computers laid out in an N √ó N mesh
    *   [Coppersmith‚ÄìWinograd algorithm](https://en.wikipedia.org/wiki/Coppersmith%E2%80%93Winograd_algorithm "Coppersmith‚ÄìWinograd algorithm"): square [matrix multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication "Matrix multiplication")
    *   [Freivalds' algorithm](https://en.wikipedia.org/wiki/Freivalds%27_algorithm "Freivalds' algorithm"): a randomized algorithm used to verify matrix multiplication
    *   [Strassen algorithm](https://en.wikipedia.org/wiki/Strassen_algorithm "Strassen algorithm"): faster [matrix multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication "Matrix multiplication")

*   Solving [systems of linear equations](https://en.wikipedia.org/wiki/System_of_linear_equations "System of linear equations")
    *   [Biconjugate gradient method](https://en.wikipedia.org/wiki/Biconjugate_gradient_method "Biconjugate gradient method"): solves systems of linear equations
    *   [Conjugate gradient](https://en.wikipedia.org/wiki/Conjugate_gradient "Conjugate gradient"): an algorithm for the numerical solution of particular systems of linear equations
    *   [Gaussian elimination](https://en.wikipedia.org/wiki/Gaussian_elimination "Gaussian elimination")
    *   [Gauss‚ÄìJordan elimination](https://en.wikipedia.org/wiki/Gauss%E2%80%93Jordan_elimination "Gauss‚ÄìJordan elimination"): solves systems of linear equations
    *   [Gauss‚ÄìSeidel method](https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method "Gauss‚ÄìSeidel method"): solves systems of linear equations iteratively
    *   [Levinson recursion](https://en.wikipedia.org/wiki/Levinson_recursion "Levinson recursion"): solves equation involving a [Toeplitz matrix](https://en.wikipedia.org/wiki/Toeplitz_matrix "Toeplitz matrix")
    *   [Stone's method](https://en.wikipedia.org/wiki/Stone%27s_method "Stone's method"): also known as the strongly implicit procedure or SIP, is an algorithm for solving a sparse linear system of equations
    *   [Successive over-relaxation](https://en.wikipedia.org/wiki/Successive_over-relaxation "Successive over-relaxation") (SOR): method used to speed up convergence of the [Gauss‚ÄìSeidel method](https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method "Gauss‚ÄìSeidel method")
    *   [Tridiagonal matrix algorithm](https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm "Tridiagonal matrix algorithm") (Thomas algorithm): solves systems of tridiagonal equations
*   [Sparse matrix](https://en.wikipedia.org/wiki/Sparse_matrix "Sparse matrix") algorithms
    *   [Cuthill‚ÄìMcKee algorithm](https://en.wikipedia.org/wiki/Cuthill%E2%80%93McKee_algorithm "Cuthill‚ÄìMcKee algorithm"): reduce the [bandwidth](https://en.wikipedia.org/wiki/Bandwidth_(matrix_theory) "Bandwidth (matrix theory)") of a [symmetric sparse matrix](https://en.wikipedia.org/wiki/Symmetric_sparse_matrix "Symmetric sparse matrix")
    *   [Minimum degree algorithm](https://en.wikipedia.org/wiki/Minimum_degree_algorithm "Minimum degree algorithm"): permute the rows and columns of a [symmetric sparse matrix](https://en.wikipedia.org/wiki/Symmetric_sparse_matrix "Symmetric sparse matrix") before applying the [Cholesky decomposition](https://en.wikipedia.org/wiki/Cholesky_decomposition "Cholesky decomposition")
    *   [Symbolic Cholesky decomposition](https://en.wikipedia.org/wiki/Symbolic_Cholesky_decomposition "Symbolic Cholesky decomposition"): Efficient way of storing [sparse matrix](https://en.wikipedia.org/wiki/Sparse_matrix "Sparse matrix")

#### Monte Carlo

Further information: [Monte Carlo method](https://en.wikipedia.org/wiki/Monte_Carlo_method "Monte Carlo method")

*   [Gibbs sampling](https://en.wikipedia.org/wiki/Gibbs_sampling "Gibbs sampling"): generate a sequence of samples from the joint probability distribution of two or more random variables
*   [Hybrid Monte Carlo](https://en.wikipedia.org/wiki/Hybrid_Monte_Carlo "Hybrid Monte Carlo"): generate a sequence of samples using [Hamiltonian](https://en.wikipedia.org/wiki/Hamiltonian_dynamics "Hamiltonian dynamics") weighted [Markov chain Monte Carlo](https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo "Markov chain Monte Carlo"), from a probability distribution which is difficult to sample directly.
*   [Metropolis‚ÄìHastings algorithm](https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm "Metropolis‚ÄìHastings algorithm"): used to generate a sequence of samples from the [probability distribution](https://en.wikipedia.org/wiki/Probability_distribution "Probability distribution") of one or more variables
*   [Wang and Landau algorithm](https://en.wikipedia.org/wiki/Wang_and_Landau_algorithm "Wang and Landau algorithm"): an extension of [Metropolis‚ÄìHastings algorithm](https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm "Metropolis‚ÄìHastings algorithm") sampling

#### Numerical integration

Further information: [Numerical integration](https://en.wikipedia.org/wiki/Numerical_integration "Numerical integration")

*   [MISER algorithm](https://en.wikipedia.org/wiki/MISER_algorithm "MISER algorithm"): Monte Carlo simulation, [numerical integration](https://en.wikipedia.org/wiki/Numerical_integration "Numerical integration")

#### Root finding

Main article: [Root-finding algorithm](https://en.wikipedia.org/wiki/Root-finding_algorithm "Root-finding algorithm")

*   [Bisection method](https://en.wikipedia.org/wiki/Bisection_method "Bisection method")
*   [False position method](https://en.wikipedia.org/wiki/False_position_method "False position method"): approximates roots of a function
*   [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method "Newton's method"): finds zeros of functions with [calculus](https://en.wikipedia.org/wiki/Calculus "Calculus")
*   [Halley's method](https://en.wikipedia.org/wiki/Halley%27s_method "Halley's method"): uses first and second derivatives
*   [Secant method](https://en.wikipedia.org/wiki/Secant_method "Secant method"): 2-point, 1-sided
*   [False position method](https://en.wikipedia.org/wiki/False_position_method "False position method") and Illinois method: 2-point, bracketing
*   [Ridder's method](https://en.wikipedia.org/wiki/Ridder%27s_method "Ridder's method"): 3-point, exponential scaling
*   [Muller's method](https://en.wikipedia.org/wiki/Muller%27s_method "Muller's method"): 3-point, quadratic interpolation

### Optimization algorithms

Main article: [Mathematical optimization](https://en.wikipedia.org/wiki/Mathematical_optimization "Mathematical optimization")

*   [Alpha‚Äìbeta pruning](https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning "Alpha‚Äìbeta pruning"): search to reduce number of nodes in minimax algorithm
*   [Branch and bound](https://en.wikipedia.org/wiki/Branch_and_bound "Branch and bound")
*   [Bruss algorithm](https://en.wikipedia.org/wiki/Bruss_algorithm "Bruss algorithm"): see [odds algorithm](https://en.wikipedia.org/wiki/Odds_algorithm "Odds algorithm")
*   [Chain matrix multiplication](https://en.wikipedia.org/wiki/Chain_matrix_multiplication "Chain matrix multiplication")
*   [Combinatorial optimization](https://en.wikipedia.org/wiki/Combinatorial_optimization "Combinatorial optimization"): optimization problems where the set of feasible solutions is discrete
    *   [Greedy randomized adaptive search procedure](https://en.wikipedia.org/wiki/Greedy_randomized_adaptive_search_procedure "Greedy randomized adaptive search procedure") (GRASP): successive constructions of a greedy randomized solution and subsequent iterative improvements of it through a local search
    *   [Hungarian method](https://en.wikipedia.org/wiki/Hungarian_method "Hungarian method"): a combinatorial optimization algorithm which solves the [assignment problem](https://en.wikipedia.org/wiki/Assignment_problem "Assignment problem") in polynomial time
*   [Constraint satisfaction](https://en.wikipedia.org/wiki/Constraint_satisfaction "Constraint satisfaction")
    *   General algorithms for the constraint satisfaction
        *   [AC-3 algorithm](https://en.wikipedia.org/wiki/AC-3_algorithm "AC-3 algorithm")
        *   [Difference map algorithm](https://en.wikipedia.org/wiki/Difference_map_algorithm "Difference map algorithm")
        *   [Min conflicts algorithm](https://en.wikipedia.org/wiki/Min_conflicts_algorithm "Min conflicts algorithm")
    *   [Chaff algorithm](https://en.wikipedia.org/wiki/Chaff_algorithm "Chaff algorithm"): an algorithm for solving instances of the boolean satisfiability problem
    *   [Davis‚ÄìPutnam algorithm](https://en.wikipedia.org/wiki/Davis%E2%80%93Putnam_algorithm "Davis‚ÄìPutnam algorithm"): check the validity of a first-order logic formula
    *   [Davis‚ÄìPutnam‚ÄìLogemann‚ÄìLoveland algorithm](https://en.wikipedia.org/wiki/DPLL_algorithm "DPLL algorithm") (DPLL): an algorithm for deciding the satisfiability of propositional logic formula in [conjunctive normal form](https://en.wikipedia.org/wiki/Conjunctive_normal_form "Conjunctive normal form"), i.e. for solving the [CNF-SAT](https://en.wikipedia.org/wiki/CNF-SAT "CNF-SAT") problem
    *   [Exact cover](https://en.wikipedia.org/wiki/Exact_cover "Exact cover") problem
        *   [Algorithm X](https://en.wikipedia.org/wiki/Algorithm_X "Algorithm X"): a [nondeterministic algorithm](https://en.wikipedia.org/wiki/Nondeterministic_algorithm "Nondeterministic algorithm")
        *   [Dancing Links](https://en.wikipedia.org/wiki/Dancing_Links "Dancing Links"): an efficient implementation of Algorithm X
*   [Cross-entropy method](https://en.wikipedia.org/wiki/Cross-entropy_method "Cross-entropy method"): a general Monte Carlo approach to combinatorial and continuous multi-extremal optimization and [importance sampling](https://en.wikipedia.org/wiki/Importance_sampling "Importance sampling")
*   [Differential evolution](https://en.wikipedia.org/wiki/Differential_evolution "Differential evolution")
*   [Dynamic Programming](https://en.wikipedia.org/wiki/Dynamic_Programming "Dynamic Programming"): problems exhibiting the properties of [overlapping subproblems](https://en.wikipedia.org/wiki/Overlapping_subproblem "Overlapping subproblem") and [optimal substructure](https://en.wikipedia.org/wiki/Optimal_substructure "Optimal substructure")
*   [Ellipsoid method](https://en.wikipedia.org/wiki/Ellipsoid_method "Ellipsoid method"): is an algorithm for solving convex optimization problems
*   [Evolutionary computation](https://en.wikipedia.org/wiki/Evolutionary_computation "Evolutionary computation"): optimization inspired by biological mechanisms of evolution
    *   [Evolution strategy](https://en.wikipedia.org/wiki/Evolution_strategy "Evolution strategy")
    *   [Gene expression programming](https://en.wikipedia.org/wiki/Gene_expression_programming "Gene expression programming")
    *   [Genetic algorithms](https://en.wikipedia.org/wiki/Genetic_algorithms "Genetic algorithms")
        *   [Fitness proportionate selection](https://en.wikipedia.org/wiki/Fitness_proportionate_selection "Fitness proportionate selection") - also known as roulette-wheel selection
        *   [Stochastic universal sampling](https://en.wikipedia.org/wiki/Stochastic_universal_sampling "Stochastic universal sampling")
        *   [Truncation selection](https://en.wikipedia.org/wiki/Truncation_selection "Truncation selection")
        *   [Tournament selection](https://en.wikipedia.org/wiki/Tournament_selection "Tournament selection")
    *   [Memetic algorithm](https://en.wikipedia.org/wiki/Memetic_algorithm "Memetic algorithm")
    *   [Swarm intelligence](https://en.wikipedia.org/wiki/Swarm_intelligence "Swarm intelligence")
        *   [Ant colony optimization](https://en.wikipedia.org/wiki/Ant_colony_optimization "Ant colony optimization")
        *   [Bees algorithm](https://en.wikipedia.org/wiki/Bees_algorithm "Bees algorithm"): a search algorithm which mimics the food foraging behavior of swarms of honey bees
        *   [Particle swarm](https://en.wikipedia.org/wiki/Particle_swarm_optimization "Particle swarm optimization")
*   [golden section search](https://en.wikipedia.org/wiki/Golden_section_search "Golden section search"): an algorithm for finding the maximum of a real function
*   [Gradient descent](https://en.wikipedia.org/wiki/Gradient_descent "Gradient descent")
*   [Harmony search](https://en.wikipedia.org/wiki/Harmony_search "Harmony search") (HS): a [metaheuristic](https://en.wikipedia.org/wiki/Metaheuristic "Metaheuristic") algorithm mimicking the improvisation process of musicians
*   [Interior point method](https://en.wikipedia.org/wiki/Interior_point_method "Interior point method")
*   [Linear programming](https://en.wikipedia.org/wiki/Linear_programming "Linear programming")
    *   [Benson's algorithm](https://en.wikipedia.org/wiki/Benson%27s_algorithm "Benson's algorithm"): an algorithm for solving linear [vector optimization](https://en.wikipedia.org/wiki/Vector_optimization "Vector optimization") problems
    *   [Dantzig‚ÄìWolfe decomposition](https://en.wikipedia.org/wiki/Dantzig%E2%80%93Wolfe_decomposition "Dantzig‚ÄìWolfe decomposition"): an algorithm for solving linear programming problems with special structure
    *   [Delayed column generation](https://en.wikipedia.org/wiki/Delayed_column_generation "Delayed column generation")
    *   [Integer linear programming](https://en.wikipedia.org/wiki/Integer_linear_programming "Integer linear programming"): solve linear programming problems where some or all the unknowns are restricted to integer values
        *   [Branch and cut](https://en.wikipedia.org/wiki/Branch_and_cut "Branch and cut")
        *   [Cutting-plane method](https://en.wikipedia.org/wiki/Cutting-plane_method "Cutting-plane method")
    *   [Karmarkar's algorithm](https://en.wikipedia.org/wiki/Karmarkar%27s_algorithm "Karmarkar's algorithm"): The first reasonably efficient algorithm that solves the [linear programming](https://en.wikipedia.org/wiki/Linear_programming "Linear programming") problem in [polynomial time](https://en.wikipedia.org/wiki/Polynomial_time "Polynomial time").
    *   [Simplex algorithm](https://en.wikipedia.org/wiki/Simplex_algorithm "Simplex algorithm"): An algorithm for solving [linear programming](https://en.wikipedia.org/wiki/Linear_programming "Linear programming") problems
*   [Line search](https://en.wikipedia.org/wiki/Line_search "Line search")
*   [Local search](https://en.wikipedia.org/wiki/Local_search_(optimization) "Local search (optimization)"): a metaheuristic for solving computationally hard optimization problems
    *   [Random-restart hill climbing](https://en.wikipedia.org/wiki/Random-restart_hill_climbing "Random-restart hill climbing")
    *   [Tabu search](https://en.wikipedia.org/wiki/Tabu_search "Tabu search")
*   [Minimax](https://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves "Minimax") used in game programming
*   [Nearest neighbor search](https://en.wikipedia.org/wiki/Nearest_neighbor_search "Nearest neighbor search") (NNS): find closest points in a [metric space](https://en.wikipedia.org/wiki/Metric_space "Metric space")
    *   [Best Bin First](https://en.wikipedia.org/wiki/Best_Bin_First "Best Bin First"): find an approximate solution to the [Nearest neighbor search](https://en.wikipedia.org/wiki/Nearest_neighbor_search "Nearest neighbor search") problem in very-high-dimensional spaces
*   [Newton's method in optimization](https://en.wikipedia.org/wiki/Newton%27s_method_in_optimization "Newton's method in optimization")
*   [Nonlinear optimization](https://en.wikipedia.org/wiki/Nonlinear_optimization "Nonlinear optimization")
    *   [BFGS method](https://en.wikipedia.org/wiki/BFGS_method "BFGS method"): A [nonlinear optimization](https://en.wikipedia.org/wiki/Nonlinear_optimization "Nonlinear optimization") algorithm
    *   [Gauss‚ÄìNewton algorithm](https://en.wikipedia.org/wiki/Gauss%E2%80%93Newton_algorithm "Gauss‚ÄìNewton algorithm"): An algorithm for solving nonlinear [least squares](https://en.wikipedia.org/wiki/Least_squares "Least squares") problems.
    *   [Levenberg‚ÄìMarquardt algorithm](https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm "Levenberg‚ÄìMarquardt algorithm"): An algorithm for solving nonlinear [least squares](https://en.wikipedia.org/wiki/Least_squares "Least squares") problems.
    *   [Nelder‚ÄìMead method](https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method "Nelder‚ÄìMead method") (downhill simplex method): A [nonlinear optimization](https://en.wikipedia.org/wiki/Nonlinear_optimization "Nonlinear optimization") algorithm
*   [Odds algorithm](https://en.wikipedia.org/wiki/Odds_algorithm "Odds algorithm") (Bruss algorithm)¬†: Finds the optimal strategy to predict a last specific event in a random sequence event
*   [Simulated annealing](https://en.wikipedia.org/wiki/Simulated_annealing "Simulated annealing")
*   [Stochastic tunneling](https://en.wikipedia.org/wiki/Stochastic_tunneling "Stochastic tunneling")
*   [Subset sum](https://en.wikipedia.org/wiki/Subset_sum_problem "Subset sum problem") algorithm

Computational science\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=35 "Edit section: Computational science")\]
-----------------------------------------------------------------------------------------------------------------------------------

Further information: [Computational science](https://en.wikipedia.org/wiki/Computational_science "Computational science")

### Astronomy

Main article: [Astronomical algorithms](https://en.wikipedia.org/wiki/Astronomical_algorithms "Astronomical algorithms")

*   [Doomsday algorithm](https://en.wikipedia.org/wiki/Doomsday_algorithm "Doomsday algorithm"): day of the week
*   [Zeller's congruence](https://en.wikipedia.org/wiki/Zeller%27s_congruence "Zeller's congruence") is an algorithm to calculate the day of the week for any Julian or Gregorian calendar date
*   various [Easter algorithms](https://en.wikipedia.org/wiki/Computus "Computus") are used to calculate the day of Easter

### Bioinformatics

Further information: [Bioinformatics](https://en.wikipedia.org/wiki/Bioinformatics "Bioinformatics")

See also: [Sequence alignment algorithms](https://en.wikipedia.org/wiki/List_of_algorithms#Sequence_alignment "List of algorithms")

*   [Basic Local Alignment Search Tool](https://en.wikipedia.org/wiki/Basic_Local_Alignment_Search_Tool "Basic Local Alignment Search Tool") also known as BLAST: an algorithm for comparing primary biological sequence information
*   [Kabsch algorithm](https://en.wikipedia.org/wiki/Kabsch_algorithm "Kabsch algorithm"): calculate the optimal alignment of two sets of points in order to compute the [root mean squared deviation](https://en.wikipedia.org/wiki/RMSD "RMSD") between two protein structures.
*   [Velvet](https://en.wikipedia.org/wiki/Velvet_(algorithm) "Velvet (algorithm)"): a set of algorithms manipulating [de Bruijn graphs](https://en.wikipedia.org/wiki/De_Bruijn_graph "De Bruijn graph") for genomic [sequence assembly](https://en.wikipedia.org/wiki/Sequence_assembly "Sequence assembly")
*   [Sorting by signed reversals](/w/index.php?title=Sorting_by_signed_reversals&action=edit&redlink=1 "Sorting by signed reversals (page does not exist)"): an algorithm for understanding genomic evolution.
*   [Maximum parsimony (phylogenetics)](https://en.wikipedia.org/wiki/Maximum_parsimony_(phylogenetics) "Maximum parsimony (phylogenetics)"): an algorithm for finding the simplest phylogenetic tree to explain a given character matrix.
*   [UPGMA](https://en.wikipedia.org/wiki/UPGMA "UPGMA"): a distance-based phylogenetic tree construction algorithm.

### Geoscience

Further information: [Geoscience](https://en.wikipedia.org/wiki/Geoscience "Geoscience")

*   [Vincenty's formulae](https://en.wikipedia.org/wiki/Vincenty%27s_formulae "Vincenty's formulae"): a fast algorithm to calculate the distance between two latitude/longitude points on an ellipsoid
*   [Geohash](https://en.wikipedia.org/wiki/Geohash "Geohash"): a public domain algorithm that encodes a decimal latitude/longitude pair as a hash string

### Linguistics

Further information: [Computational linguistics](https://en.wikipedia.org/wiki/Computational_linguistics "Computational linguistics") and [Natural language processing](https://en.wikipedia.org/wiki/Natural_language_processing "Natural language processing")

*   [Lesk algorithm](https://en.wikipedia.org/wiki/Lesk_algorithm "Lesk algorithm"): word sense disambiguation
*   [Stemming algorithm](https://en.wikipedia.org/wiki/Stemming "Stemming"): a method of reducing words to their stem, base, or root form
*   [Sukhotin's algorithm](https://en.wikipedia.org/wiki/Sukhotin%27s_algorithm "Sukhotin's algorithm"): a statistical classification algorithm for classifying characters in a text as vowels or consonants

### Medicine

Further information: [Medical algorithms](https://en.wikipedia.org/wiki/Medical_algorithms "Medical algorithms")

*   [ESC algorithm](https://en.wikipedia.org/wiki/ESC_algorithm "ESC algorithm") for the diagnosis of heart failure
*   [Manning Criteria](https://en.wikipedia.org/wiki/Manning_Criteria "Manning Criteria") for irritable bowel syndrome
*   [Pulmonary embolism](https://en.wikipedia.org/wiki/Pulmonary_embolism#Algorithms "Pulmonary embolism") diagnostic algorithms
*   [Texas Medication Algorithm Project](https://en.wikipedia.org/wiki/Texas_Medication_Algorithm_Project "Texas Medication Algorithm Project")

### Physics

Further information: [Computational physics](https://en.wikipedia.org/wiki/Computational_physics "Computational physics")

*   [Constraint algorithm](https://en.wikipedia.org/wiki/Constraint_algorithm "Constraint algorithm"): a class of algorithms for satisfying constraints for bodies that obey Newton's equations of motion
*   [Demon algorithm](https://en.wikipedia.org/wiki/Demon_algorithm "Demon algorithm"): a [Monte Carlo method](https://en.wikipedia.org/wiki/Monte_Carlo_method "Monte Carlo method") for efficiently sampling members of a [microcanonical ensemble](https://en.wikipedia.org/wiki/Microcanonical_ensemble "Microcanonical ensemble") with a given energy
*   [Featherstone's algorithm](https://en.wikipedia.org/wiki/Featherstone%27s_algorithm "Featherstone's algorithm"): compute the effects of forces applied to a structure of joints and links
*   [Ground state](https://en.wikipedia.org/wiki/Ground_state "Ground state") approximation
    *   [Variational method](https://en.wikipedia.org/wiki/Variational_method "Variational method")
        *   [Ritz method](https://en.wikipedia.org/wiki/Ritz_method "Ritz method")
*   [N-body problems](https://en.wikipedia.org/wiki/N-body_problem "N-body problem")
    *   [Barnes‚ÄìHut simulation](https://en.wikipedia.org/wiki/Barnes%E2%80%93Hut_simulation "Barnes‚ÄìHut simulation"): Solves the n-body problem in an approximate way that has the order O(n log n) instead of O(n2) as in a direct-sum simulation.
    *   [Fast multipole method](https://en.wikipedia.org/wiki/Fast_multipole_method "Fast multipole method") (FMM): speeds up the calculation of long-ranged forces
*   [Rainflow-counting algorithm](https://en.wikipedia.org/wiki/Rainflow-counting_algorithm "Rainflow-counting algorithm"): Reduces a complex [stress](https://en.wikipedia.org/wiki/Stress_(physics) "Stress (physics)") history to a count of elementary stress-reversals for use in [fatigue](https://en.wikipedia.org/wiki/Fatigue_(material) "Fatigue (material)") analysis
*   [Sweep and prune](https://en.wikipedia.org/wiki/Sweep_and_prune "Sweep and prune"): a broad phase algorithm used during [collision detection](https://en.wikipedia.org/wiki/Collision_detection "Collision detection") to limit the number of pairs of solids that need to be checked for collision
*   [VEGAS algorithm](https://en.wikipedia.org/wiki/VEGAS_algorithm "VEGAS algorithm"): a method for reducing error in [Monte Carlo simulations](https://en.wikipedia.org/wiki/Monte_Carlo_simulation "Monte Carlo simulation")

### Statistics

Further information: [Computational statistics](https://en.wikipedia.org/wiki/Computational_statistics "Computational statistics")

*   [Algorithms for calculating variance](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance "Algorithms for calculating variance"): avoiding instability and numerical overflow
*   [Approximate counting algorithm](https://en.wikipedia.org/wiki/Approximate_counting_algorithm "Approximate counting algorithm"): Allows counting large number of events in a small register
*   [Bayesian statistics](https://en.wikipedia.org/wiki/Bayesian_statistics "Bayesian statistics")
    *   [Nested sampling algorithm](https://en.wikipedia.org/wiki/Nested_sampling_algorithm "Nested sampling algorithm"): a computational approach to the problem of comparing models in Bayesian statistics
*   [Clustering Algorithms](https://en.wikipedia.org/wiki/Data_clustering "Data clustering")
    *   [Average-linkage clustering](https://en.wikipedia.org/wiki/UPGMA "UPGMA"): a simple agglomerative clustering algorithm
    *   [Canopy clustering algorithm](https://en.wikipedia.org/wiki/Canopy_clustering_algorithm "Canopy clustering algorithm"): an unsupervised pre-clustering algorithm related to the K-means algorithm
    *   [Complete-linkage clustering](https://en.wikipedia.org/wiki/Complete-linkage_clustering "Complete-linkage clustering"): a simple agglomerative clustering algorithm
    *   [DBSCAN](https://en.wikipedia.org/wiki/DBSCAN "DBSCAN"): a density based clustering algorithm
    *   [Expectation-maximization algorithm](https://en.wikipedia.org/wiki/Expectation-maximization_algorithm "Expectation-maximization algorithm")
    *   [Fuzzy clustering](https://en.wikipedia.org/wiki/Fuzzy_clustering "Fuzzy clustering"): a class of clustering algorithms where each point has a degree of belonging to clusters
        *   [Fuzzy c-means](https://en.wikipedia.org/wiki/Fuzzy_clustering#Fuzzy_c-means_clustering "Fuzzy clustering")
        *   [FLAME clustering](https://en.wikipedia.org/wiki/FLAME_clustering "FLAME clustering") (Fuzzy clustering by Local Approximation of MEmberships): define clusters in the dense parts of a dataset and perform cluster assignment solely based on the neighborhood relationships among objects
    *   [KHOPCA clustering algorithm](https://en.wikipedia.org/wiki/KHOPCA_clustering_algorithm "KHOPCA clustering algorithm"): a local clustering algorithm, which produces hierarchical multi-hop clusters in static and mobile environments.
    *   [k-means clustering](https://en.wikipedia.org/wiki/K-means_clustering "K-means clustering"): cluster objects based on attributes into partitions
    *   [k-means++](https://en.wikipedia.org/wiki/K-means%2B%2B "K-means++"): a variation of this, using modified random seeds
    *   [k-medoids](https://en.wikipedia.org/wiki/K-medoids "K-medoids"): similar to k-means, but chooses datapoints or [medoids](https://en.wikipedia.org/wiki/Medoid "Medoid") as centers
    *   [Linde‚ÄìBuzo‚ÄìGray algorithm](https://en.wikipedia.org/wiki/Linde%E2%80%93Buzo%E2%80%93Gray_algorithm "Linde‚ÄìBuzo‚ÄìGray algorithm"): a vector quantization algorithm to derive a good codebook
    *   [Lloyd's algorithm](https://en.wikipedia.org/wiki/Lloyd%27s_algorithm "Lloyd's algorithm") (Voronoi iteration or relaxation): group data points into a given number of categories, a popular algorithm for [k-means clustering](https://en.wikipedia.org/wiki/K-means_clustering "K-means clustering")
    *   [OPTICS](https://en.wikipedia.org/wiki/OPTICS_algorithm "OPTICS algorithm"): a density based clustering algorithm with a visual evaluation method
    *   [Single-linkage clustering](https://en.wikipedia.org/wiki/Single-linkage_clustering "Single-linkage clustering"): a simple agglomerative clustering algorithm
    *   [SUBCLU](https://en.wikipedia.org/wiki/SUBCLU "SUBCLU"): a subspace clustering algorithm
    *   [Ward's method](https://en.wikipedia.org/wiki/Ward%27s_method "Ward's method")¬†: an agglomerative clustering algorithm, extended to more general Lance‚ÄìWilliams algorithms
    *   [WACA clustering algorithm](https://en.wikipedia.org/wiki/WACA_clustering_algorithm "WACA clustering algorithm"): a local clustering algorithm with potentially multi-hop structures; for dynamic networks
*   [Estimation Theory](https://en.wikipedia.org/wiki/Estimation_theory "Estimation theory")
    *   [Expectation-maximization algorithm](https://en.wikipedia.org/wiki/Expectation-maximization_algorithm "Expectation-maximization algorithm") A class of related algorithms for finding maximum likelihood estimates of parameters in probabilistic models
        *   [Ordered subset expectation maximization](https://en.wikipedia.org/wiki/Ordered_subset_expectation_maximization "Ordered subset expectation maximization") (OSEM): used in [medical imaging](https://en.wikipedia.org/wiki/Medical_imaging "Medical imaging") for [positron emission tomography](https://en.wikipedia.org/wiki/Positron_emission_tomography "Positron emission tomography"), [single photon emission computed tomography](https://en.wikipedia.org/wiki/Single_photon_emission_computed_tomography "Single photon emission computed tomography") and [X-ray](https://en.wikipedia.org/wiki/X-ray "X-ray") computed tomography.
    *   [Odds algorithm](https://en.wikipedia.org/wiki/Odds_algorithm "Odds algorithm") (Bruss algorithm) Optimal online search for distinguished value in sequential random input
    *   [Kalman filter](https://en.wikipedia.org/wiki/Kalman_filter "Kalman filter"): estimate the state of a linear [dynamic system](https://en.wikipedia.org/wiki/Dynamical_system "Dynamical system") from a series of noisy measurements
*   [False nearest neighbor algorithm](https://en.wikipedia.org/wiki/False_nearest_neighbor_algorithm "False nearest neighbor algorithm") (FNN) estimates [fractal dimension](https://en.wikipedia.org/wiki/Fractal_dimension "Fractal dimension")
*   [Hidden Markov model](https://en.wikipedia.org/wiki/Hidden_Markov_model "Hidden Markov model")
    *   [Baum‚ÄìWelch algorithm](https://en.wikipedia.org/wiki/Baum%E2%80%93Welch_algorithm "Baum‚ÄìWelch algorithm"): compute maximum likelihood estimates and [posterior mode](https://en.wikipedia.org/wiki/Maximum_a_posteriori "Maximum a posteriori") estimates for the parameters of a [hidden markov model](https://en.wikipedia.org/wiki/Hidden_markov_model "Hidden markov model")
    *   [Forward-backward algorithm](https://en.wikipedia.org/wiki/Forward-backward_algorithm "Forward-backward algorithm") a dynamic programming algorithm for computing the probability of a particular observation sequence
    *   [Viterbi algorithm](https://en.wikipedia.org/wiki/Viterbi_algorithm "Viterbi algorithm"): find the most likely sequence of hidden states in a [hidden markov model](https://en.wikipedia.org/wiki/Hidden_markov_model "Hidden markov model")
*   [Partial least squares regression](https://en.wikipedia.org/wiki/Partial_least_squares_regression "Partial least squares regression"): finds a linear model describing some predicted variables in terms of other observable variables
*   [Queuing theory](https://en.wikipedia.org/wiki/Queuing_theory "Queuing theory")
    *   [Buzen's algorithm](https://en.wikipedia.org/wiki/Buzen%27s_algorithm "Buzen's algorithm"): an algorithm for calculating the normalization constant G(K) in the [Gordon‚ÄìNewell theorem](https://en.wikipedia.org/wiki/Gordon%E2%80%93Newell_theorem "Gordon‚ÄìNewell theorem")
*   [RANSAC](https://en.wikipedia.org/wiki/RANSAC "RANSAC") (an abbreviation for "RANdom SAmple Consensus"): an iterative method to estimate parameters of a mathematical model from a set of observed data which contains outliers
*   [Scoring algorithm](https://en.wikipedia.org/wiki/Scoring_algorithm "Scoring algorithm"): is a form of [Newton's method](https://en.wikipedia.org/wiki/Newton%27s_method "Newton's method") used to solve [maximum likelihood](https://en.wikipedia.org/wiki/Maximum_likelihood "Maximum likelihood") equations numerically
*   [Yamartino method](https://en.wikipedia.org/wiki/Yamartino_method "Yamartino method"): calculate an approximation to the standard deviation œÉŒ∏ of wind direction Œ∏ during a single pass through the incoming data
*   [Ziggurat algorithm](https://en.wikipedia.org/wiki/Ziggurat_algorithm "Ziggurat algorithm"): generate random numbers from a non-uniform distribution

Computer science\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=43 "Edit section: Computer science")\]
-------------------------------------------------------------------------------------------------------------------------

Further information: [Computer science](https://en.wikipedia.org/wiki/Computer_science "Computer science")

### Computer architecture

Further information: [Computer architecture](https://en.wikipedia.org/wiki/Computer_architecture "Computer architecture")

*   [Tomasulo algorithm](https://en.wikipedia.org/wiki/Tomasulo_algorithm "Tomasulo algorithm"): allows sequential instructions that would normally be stalled due to certain dependencies to execute non-sequentially

### Computer graphics

Further information: [Computer graphics](https://en.wikipedia.org/wiki/Computer_graphics "Computer graphics")

*   [Clipping](https://en.wikipedia.org/wiki/Clipping_(computer_graphics) "Clipping (computer graphics)")
    *   [Line clipping](https://en.wikipedia.org/wiki/Line_clipping "Line clipping")
        *   [Cohen‚ÄìSutherland](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland "Cohen‚ÄìSutherland")
        *   [Cyrus‚ÄìBeck](https://en.wikipedia.org/wiki/Cyrus%E2%80%93Beck "Cyrus‚ÄìBeck")
        *   [Fast-clipping](https://en.wikipedia.org/wiki/Fast_clipping "Fast clipping")
        *   [Liang‚ÄìBarsky](https://en.wikipedia.org/wiki/Liang%E2%80%93Barsky "Liang‚ÄìBarsky")
        *   [Nicholl‚ÄìLee‚ÄìNicholl](https://en.wikipedia.org/wiki/Nicholl%E2%80%93Lee%E2%80%93Nicholl "Nicholl‚ÄìLee‚ÄìNicholl")
    *   Polygon clipping
        *   [Sutherland‚ÄìHodgman](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman "Sutherland‚ÄìHodgman")
        *   [Vatti](https://en.wikipedia.org/wiki/Vatti_clipping_algorithm "Vatti clipping algorithm")
        *   [Weiler‚ÄìAtherton](https://en.wikipedia.org/wiki/Weiler%E2%80%93Atherton "Weiler‚ÄìAtherton")
*   [Contour lines](https://en.wikipedia.org/wiki/Contour_line "Contour line") and [Isosurfaces](https://en.wikipedia.org/wiki/Isosurface "Isosurface")
    *   [Marching cubes](https://en.wikipedia.org/wiki/Marching_cubes "Marching cubes"): extract a polygonal mesh of an isosurface from a three-dimensional scalar field (sometimes called voxels)
    *   [Marching squares](https://en.wikipedia.org/wiki/Marching_squares "Marching squares"): generate contour lines for a two-dimensional scalar field
    *   [Marching tetrahedrons](https://en.wikipedia.org/wiki/Marching_tetrahedrons "Marching tetrahedrons"): an alternative to [Marching cubes](https://en.wikipedia.org/wiki/Marching_cubes "Marching cubes")
*   [Discrete Green's Theorem](/w/index.php?title=Discrete_Green%27s_Theorem&action=edit&redlink=1 "Discrete Green's Theorem (page does not exist)"): is an algorithm for computing double integral over a generalized rectangular domain in constant time. It is a natural extension to the summed area table algorithm
*   [Flood fill](https://en.wikipedia.org/wiki/Flood_fill "Flood fill"): fills a connected region of a multi-dimensional array with a specified symbol
*   [Global illumination](https://en.wikipedia.org/wiki/Global_illumination "Global illumination") algorithms: Considers direct illumination and reflection from other objects.
    *   [Ambient occlusion](https://en.wikipedia.org/wiki/Ambient_occlusion "Ambient occlusion")
    *   [Beam tracing](https://en.wikipedia.org/wiki/Beam_tracing "Beam tracing")
    *   [Cone tracing](https://en.wikipedia.org/wiki/Cone_tracing "Cone tracing")
    *   [Image-based lighting](https://en.wikipedia.org/wiki/Image-based_lighting "Image-based lighting")
    *   [Metropolis light transport](https://en.wikipedia.org/wiki/Metropolis_light_transport "Metropolis light transport")
    *   [Path tracing](https://en.wikipedia.org/wiki/Path_tracing "Path tracing")
    *   [Photon mapping](https://en.wikipedia.org/wiki/Photon_mapping "Photon mapping")
    *   [Radiosity](https://en.wikipedia.org/wiki/Radiosity_(3D_computer_graphics) "Radiosity (3D computer graphics)")
    *   [Ray tracing](https://en.wikipedia.org/wiki/Ray_tracing_(graphics) "Ray tracing (graphics)")
*   [Hidden surface removal](https://en.wikipedia.org/wiki/Hidden_surface_determination "Hidden surface determination") or [Visual surface determination](https://en.wikipedia.org/wiki/Hidden_surface_determination "Hidden surface determination")
    *   [Newell's algorithm](https://en.wikipedia.org/wiki/Newell%27s_algorithm "Newell's algorithm"): eliminate polygon cycles in the depth sorting required in hidden surface removal
    *   [Painter's algorithm](https://en.wikipedia.org/wiki/Painter%27s_algorithm "Painter's algorithm"): detects visible parts of a 3-dimensional scenery
    *   [Scanline rendering](https://en.wikipedia.org/wiki/Scanline_rendering "Scanline rendering"): constructs an image by moving an imaginary line over the image
    *   [Warnock algorithm](https://en.wikipedia.org/wiki/Warnock_algorithm "Warnock algorithm")
*   [Line Drawing](https://en.wikipedia.org/wiki/Line_drawing_algorithm "Line drawing algorithm"): graphical algorithm for approximating a line segment on discrete graphical media.
    *   [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm "Bresenham's line algorithm"): plots points of a 2-dimensional array to form a straight line between 2 specified points (uses decision variables)
    *   [DDA line algorithm](https://en.wikipedia.org/wiki/Digital_Differential_Analyzer_(graphics_algorithm) "Digital Differential Analyzer (graphics algorithm)"): plots points of a 2-dimensional array to form a straight line between 2 specified points (uses floating-point math)
    *   [Xiaolin Wu's line algorithm](https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm "Xiaolin Wu's line algorithm"): algorithm for line antialiasing.
*   [Midpoint circle algorithm](https://en.wikipedia.org/wiki/Midpoint_circle_algorithm "Midpoint circle algorithm"): an algorithm used to determine the points needed for drawing a circle
*   [Ramer‚ÄìDouglas‚ÄìPeucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm "Ramer‚ÄìDouglas‚ÄìPeucker algorithm"): Given a 'curve' composed of line segments to find a curve not too dissimilar but that has fewer points
*   [Shading](https://en.wikipedia.org/wiki/Shading "Shading")
    *   [Gouraud shading](https://en.wikipedia.org/wiki/Gouraud_shading "Gouraud shading"): an algorithm to simulate the differing effects of light and colour across the surface of an object in 3D computer graphics
    *   [Phong shading](https://en.wikipedia.org/wiki/Phong_shading "Phong shading"): an algorithm to interpolate surface normal-vectors for surface shading in 3D computer graphics
*   [Slerp](https://en.wikipedia.org/wiki/Slerp "Slerp") (spherical linear interpolation): quaternion interpolation for the purpose of animating 3D rotation
*   [Summed area table](https://en.wikipedia.org/wiki/Summed_area_table "Summed area table") (also known as an integral image): an algorithm for computing the sum of values in a rectangular subset of a grid in constant time

### Cryptography

Further information: [Cryptography](https://en.wikipedia.org/wiki/Cryptography "Cryptography") and [Topics in cryptography](https://en.wikipedia.org/wiki/Topics_in_cryptography "Topics in cryptography")

*   [Asymmetric (public key) encryption](https://en.wikipedia.org/wiki/Asymmetric_key_algorithm "Asymmetric key algorithm"):
    *   [ElGamal](https://en.wikipedia.org/wiki/ElGamal_encryption "ElGamal encryption")
    *   [Elliptic curve cryptography](https://en.wikipedia.org/wiki/Elliptic_curve_cryptography "Elliptic curve cryptography")
    *   [MAE1](/w/index.php?title=Matei_Array_Encreption_1&action=edit&redlink=1 "Matei Array Encreption 1 (page does not exist)")
    *   [NTRUEncrypt](https://en.wikipedia.org/wiki/NTRUEncrypt "NTRUEncrypt")
    *   [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem) "RSA (cryptosystem)")
*   [Digital signatures](https://en.wikipedia.org/wiki/Digital_signature "Digital signature") (asymmetric authentication):
    *   [DSA](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm "Digital Signature Algorithm"), and its variants:
        *   [ECDSA](https://en.wikipedia.org/wiki/ECDSA "ECDSA") and [Deterministic ECDSA](https://tools.ietf.org/html/rfc6979)
        *   [EdDSA](https://en.wikipedia.org/wiki/EdDSA "EdDSA") (Ed25519)
    *   [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem) "RSA (cryptosystem)")
*   [Cryptographic hash functions](https://en.wikipedia.org/wiki/Cryptographic_hash_function "Cryptographic hash function") (see also the section on message authentication codes):
    *   [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function) "BLAKE (hash function)")
    *   [MD5](https://en.wikipedia.org/wiki/MD5 "MD5") ‚Äì Note that there is now a method of generating collisions for MD5
    *   [RIPEMD-160](https://en.wikipedia.org/wiki/RIPEMD-160 "RIPEMD-160")
    *   [SHA-1](https://en.wikipedia.org/wiki/SHA-1 "SHA-1") ‚Äì Note that there is now a method of generating collisions for SHA-1
    *   [SHA-2](https://en.wikipedia.org/wiki/SHA-2 "SHA-2") (SHA-224, SHA-256, SHA-384, SHA-512)
    *   [SHA-3](https://en.wikipedia.org/wiki/SHA-3 "SHA-3") (SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256)
    *   [Tiger](https://en.wikipedia.org/wiki/Tiger_(hash) "Tiger (hash)") (TTH), usually used in [Tiger tree hashes](https://en.wikipedia.org/wiki/Hash_tree_(persistent_data_structure) "Hash tree (persistent data structure)")
    *   [WHIRLPOOL](https://en.wikipedia.org/wiki/WHIRLPOOL "WHIRLPOOL")
*   [Cryptographically secure pseudo-random number generators](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator "Cryptographically secure pseudo-random number generator")
    *   [Blum Blum Shub](https://en.wikipedia.org/wiki/Blum_Blum_Shub "Blum Blum Shub") - based on the hardness of [factorization](https://en.wikipedia.org/wiki/Integer_factorization "Integer factorization")
    *   [Fortuna](https://en.wikipedia.org/wiki/Fortuna_(PRNG) "Fortuna (PRNG)"), intended as an improvement on [Yarrow algorithm](https://en.wikipedia.org/wiki/Yarrow_algorithm "Yarrow algorithm")
    *   [Linear-feedback shift register](https://en.wikipedia.org/wiki/Linear-feedback_shift_register "Linear-feedback shift register") (note: many LFSR-based algorithms are weak or have been broken)
    *   [Yarrow algorithm](https://en.wikipedia.org/wiki/Yarrow_algorithm "Yarrow algorithm")
*   [Key exchange](https://en.wikipedia.org/wiki/Key_exchange "Key exchange")
    *   [Diffie‚ÄìHellman key exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange "Diffie‚ÄìHellman key exchange")
    *   [Elliptic-curve Diffie-Hellman](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie-Hellman "Elliptic-curve Diffie-Hellman") (ECDH)
*   [Key derivation functions](https://en.wikipedia.org/wiki/Key_derivation_function "Key derivation function"), often used for [password hashing](https://en.wikipedia.org/wiki/Password_hashing "Password hashing") and [key stretching](https://en.wikipedia.org/wiki/Key_stretching "Key stretching")
    *   [bcrypt](https://en.wikipedia.org/wiki/Bcrypt "Bcrypt")
    *   [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2 "PBKDF2")
    *   [scrypt](https://en.wikipedia.org/wiki/Scrypt "Scrypt")
    *   [Argon2](https://en.wikipedia.org/wiki/Argon2 "Argon2")
*   [Message authentication codes](https://en.wikipedia.org/wiki/Message_authentication_code "Message authentication code") (symmetric authentication algorithms, which take a key as a parameter):
    *   [HMAC](https://en.wikipedia.org/wiki/Keyed-hash_message_authentication_code "Keyed-hash message authentication code"): keyed-hash message authentication
    *   [Poly1305](https://en.wikipedia.org/wiki/Poly1305 "Poly1305")
    *   [SipHash](https://en.wikipedia.org/wiki/SipHash "SipHash")
*   [Secret sharing](https://en.wikipedia.org/wiki/Secret_sharing "Secret sharing"), Secret Splitting, Key Splitting, M of N algorithms
    *   Blakey's Scheme
    *   [Shamir's Scheme](https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing "Shamir's Secret Sharing")
*   [Symmetric (secret key) encryption](https://en.wikipedia.org/wiki/Symmetric_key_algorithm "Symmetric key algorithm"):
    *   [Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard "Advanced Encryption Standard") (AES), winner of [NIST](https://en.wikipedia.org/wiki/NIST "NIST") competition, also known as [Rijndael](https://en.wikipedia.org/wiki/Rijndael "Rijndael")
    *   [Blowfish](https://en.wikipedia.org/wiki/Blowfish_(cipher) "Blowfish (cipher)")
    *   [Twofish](https://en.wikipedia.org/wiki/Twofish "Twofish")
    *   [Threefish](https://en.wikipedia.org/wiki/Threefish "Threefish")
    *   [Data Encryption Standard](https://en.wikipedia.org/wiki/Data_Encryption_Standard "Data Encryption Standard") (DES), sometimes DE Algorithm, winner of NBS selection competition, replaced by AES for most purposes
    *   [IDEA](https://en.wikipedia.org/wiki/International_Data_Encryption_Algorithm "International Data Encryption Algorithm")
    *   [RC4 (cipher)](https://en.wikipedia.org/wiki/RC4_(cipher) "RC4 (cipher)")
    *   [Tiny Encryption Algorithm](https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm "Tiny Encryption Algorithm") (TEA)
    *   [Salsa20](https://en.wikipedia.org/wiki/Salsa20 "Salsa20"), and its updated variant [ChaCha20](https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant "Salsa20")
*   [Post-quantum cryptography](https://en.wikipedia.org/wiki/Post-quantum_cryptography "Post-quantum cryptography")
*   [Proof-of-work algorithms](https://en.wikipedia.org/wiki/Proof-of-work_system "Proof-of-work system")

### Digital logic

*   Boolean minimization
    *   [Quine‚ÄìMcCluskey algorithm](https://en.wikipedia.org/wiki/Quine%E2%80%93McCluskey_algorithm "Quine‚ÄìMcCluskey algorithm"): Also called as Q-M algorithm, programmable method for simplifying the boolean equations.
    *   [Petrick's method](https://en.wikipedia.org/wiki/Petrick%27s_method "Petrick's method"): Another algorithm for boolean simplification.
    *   [Espresso heuristic logic minimizer](https://en.wikipedia.org/wiki/Espresso_heuristic_logic_minimizer "Espresso heuristic logic minimizer"): Fast algorithm for boolean function minimization.

### Machine learning and statistical classification

Main article: [List of machine learning algorithms](https://en.wikipedia.org/wiki/List_of_machine_learning_algorithms "List of machine learning algorithms")

Further information: [Machine learning](https://en.wikipedia.org/wiki/Machine_learning "Machine learning") and [Statistical classification](https://en.wikipedia.org/wiki/Statistical_classification "Statistical classification")

*   [ALOPEX](https://en.wikipedia.org/wiki/ALOPEX "ALOPEX"): a correlation-based [machine-learning algorithm](https://en.wikipedia.org/wiki/Machine_learning "Machine learning")
*   [Association rule learning](https://en.wikipedia.org/wiki/Association_rule_learning "Association rule learning"): discover interesting relations between variables, used in [data mining](https://en.wikipedia.org/wiki/Data_mining "Data mining")
    *   [Apriori algorithm](https://en.wikipedia.org/wiki/Apriori_algorithm "Apriori algorithm")
    *   [Eclat algorithm](https://en.wikipedia.org/wiki/Eclat_algorithm "Eclat algorithm")
    *   [FP-growth algorithm](https://en.wikipedia.org/wiki/Association_rule_learning#FP-growth_algorithm "Association rule learning")
    *   [One-attribute rule](https://en.wikipedia.org/wiki/One-attribute_rule "One-attribute rule")
    *   [Zero-attribute rule](https://en.wikipedia.org/wiki/Association_rule_learning#Zero-attribute_rule "Association rule learning")
*   [Boosting (meta-algorithm)](https://en.wikipedia.org/wiki/Boosting_(meta-algorithm) "Boosting (meta-algorithm)"): Use many weak learners to boost effectiveness
    *   [AdaBoost](https://en.wikipedia.org/wiki/AdaBoost "AdaBoost"): adaptive boosting
    *   [BrownBoost](https://en.wikipedia.org/wiki/BrownBoost "BrownBoost"):a boosting algorithm that may be robust to noisy datasets
    *   [LogitBoost](https://en.wikipedia.org/wiki/LogitBoost "LogitBoost"): [logistic regression](https://en.wikipedia.org/wiki/Logistic_regression "Logistic regression") boosting
    *   [LPBoost](https://en.wikipedia.org/wiki/LPBoost "LPBoost"): [linear programming](https://en.wikipedia.org/wiki/Linear_programming "Linear programming") boosting
*   [Bootstrap aggregating](https://en.wikipedia.org/wiki/Bootstrap_aggregating "Bootstrap aggregating") (bagging): technique to improve stability and classification accuracy
*   [Computer Vision](https://en.wikipedia.org/wiki/Computer_Vision "Computer Vision")
    *   [Grabcut](https://en.wikipedia.org/wiki/Grabcut "Grabcut") based on [Graph cuts](https://en.wikipedia.org/wiki/Graph_cuts_in_computer_vision "Graph cuts in computer vision")
*   [Decision Trees](https://en.wikipedia.org/wiki/Decision_tree_learning "Decision tree learning")
    *   [C4.5 algorithm](https://en.wikipedia.org/wiki/C4.5_algorithm "C4.5 algorithm"): an extension to ID3
    *   [ID3 algorithm](https://en.wikipedia.org/wiki/ID3_algorithm "ID3 algorithm") (Iterative Dichotomiser 3): Use heuristic to generate small decision trees
*   [Clustering](https://en.wikipedia.org/wiki/Cluster_analysis "Cluster analysis"): Class of [unsupervised learning](https://en.wikipedia.org/wiki/Unsupervised_learning "Unsupervised learning") algorithms for grouping and bucketing related input vector.
    *   [k-nearest neighbors](https://en.wikipedia.org/wiki/K-nearest_neighbors "K-nearest neighbors") (k-NN): a method for classifying objects based on closest training examples in the [feature space](https://en.wikipedia.org/wiki/Feature_space "Feature space")
*   [Linde‚ÄìBuzo‚ÄìGray algorithm](https://en.wikipedia.org/wiki/Linde%E2%80%93Buzo%E2%80%93Gray_algorithm "Linde‚ÄìBuzo‚ÄìGray algorithm"): a vector quantization algorithm used to derive a good codebook
*   [Locality-sensitive hashing](https://en.wikipedia.org/wiki/Locality-sensitive_hashing "Locality-sensitive hashing") (LSH): a method of performing probabilistic dimension reduction of high-dimensional data
*   [Neural Network](https://en.wikipedia.org/wiki/Artificial_neural_network "Artificial neural network")
    *   [Backpropagation](https://en.wikipedia.org/wiki/Backpropagation "Backpropagation"): A [supervised learning](https://en.wikipedia.org/wiki/Supervised_learning "Supervised learning") method which requires a teacher that knows, or can calculate, the desired output for any given input
    *   [Hopfield net](https://en.wikipedia.org/wiki/Hopfield_net "Hopfield net"): a [Recurrent neural network](https://en.wikipedia.org/wiki/Recurrent_neural_network "Recurrent neural network") in which all connections are symmetric
    *   [Perceptron](https://en.wikipedia.org/wiki/Perceptron "Perceptron"): the simplest kind of feedforward neural network: a [linear classifier](https://en.wikipedia.org/wiki/Linear_classifier "Linear classifier").
    *   [Pulse-coupled neural networks](https://en.wikipedia.org/wiki/Pulse-coupled_neural_networks "Pulse-coupled neural networks") (PCNN): [Neural models](https://en.wikipedia.org/wiki/Artificial_neural_network "Artificial neural network") proposed by modeling a cat's [visual cortex](https://en.wikipedia.org/wiki/Visual_cortex "Visual cortex") and developed for high-performance [biomimetic](https://en.wikipedia.org/wiki/Bionics "Bionics") image processing.
    *   [Radial basis function network](https://en.wikipedia.org/wiki/Radial_basis_function_network "Radial basis function network"): an artificial neural network that uses radial [basis functions](https://en.wikipedia.org/wiki/Basis_function "Basis function") as activation functions
    *   [Self-organizing map](https://en.wikipedia.org/wiki/Self-organizing_map "Self-organizing map"): an unsupervised network that produces a low-dimensional representation of the input space of the training samples
*   [Random forest](https://en.wikipedia.org/wiki/Random_forest "Random forest"): classify using many decision trees
*   [Reinforcement Learning](https://en.wikipedia.org/wiki/Reinforcement_Learning "Reinforcement Learning"):
    *   [Q-learning](https://en.wikipedia.org/wiki/Q-learning "Q-learning"): learn an action-value function that gives the expected utility of taking a given action in a given state and following a fixed policy thereafter
    *   [State-Action-Reward-State-Action](https://en.wikipedia.org/wiki/State-Action-Reward-State-Action "State-Action-Reward-State-Action") (SARSA): learn a [Markov decision process](https://en.wikipedia.org/wiki/Markov_decision_process "Markov decision process") policy
    *   [Temporal difference learning](https://en.wikipedia.org/wiki/Temporal_difference_learning "Temporal difference learning")
*   [Relevance Vector Machine](https://en.wikipedia.org/wiki/Relevance_Vector_Machine "Relevance Vector Machine") (RVM): similar to SVM, but provides probabilistic classification
*   [Supervised Learning](/w/index.php?title=Supervised_Learning&action=edit&redlink=1 "Supervised Learning (page does not exist)"): Learning by examples (labelled data-set split into training-set and test-set)
*   [Support Vector Machines](https://en.wikipedia.org/wiki/Support_Vector_Machines "Support Vector Machines") (SVM): a set of methods which divide multidimensional data by finding a dividing hyperplane with the maximum margin between the two sets
    *   [Structured SVM](https://en.wikipedia.org/wiki/Structured_SVM "Structured SVM"): allows training of a classifier for general structured output labels.
*   [Winnow algorithm](https://en.wikipedia.org/wiki/Winnow_algorithm "Winnow algorithm"): related to the perceptron, but uses a [multiplicative weight-update scheme](https://en.wikipedia.org/wiki/Multiplicative_Weight_Update_Method "Multiplicative Weight Update Method")

### Programming language theory

Further information: [Programming language theory](https://en.wikipedia.org/wiki/Programming_language_theory "Programming language theory")

*   [C3 linearization](https://en.wikipedia.org/wiki/C3_linearization "C3 linearization"): an algorithm used primarily to obtain a consistent linearization of a multiple inheritance hierarchy in object-oriented programming
*   [Chaitin's algorithm](https://en.wikipedia.org/wiki/Chaitin%27s_algorithm "Chaitin's algorithm"): a bottom-up, graph coloring register allocation algorithm that uses cost/degree as its spill metric
*   [Hindley‚ÄìMilner type inference algorithm](https://en.wikipedia.org/wiki/Hindley-Milner_type_inference "Hindley-Milner type inference")
*   [Rete algorithm](https://en.wikipedia.org/wiki/Rete_algorithm "Rete algorithm"): an efficient pattern matching algorithm for implementing [production rule](https://en.wikipedia.org/wiki/Start_symbol_(formal_languages) "Start symbol (formal languages)") systems
*   [Sethi-Ullman algorithm](https://en.wikipedia.org/wiki/Sethi-Ullman_algorithm "Sethi-Ullman algorithm"): generate optimal code for arithmetic expressions

#### Parsing

Further information: [Parsing](https://en.wikipedia.org/wiki/Parsing "Parsing")

*   [CYK algorithm](https://en.wikipedia.org/wiki/CYK_algorithm "CYK algorithm"): An O(n3) algorithm for parsing [context-free grammars](https://en.wikipedia.org/wiki/Context-free_grammar "Context-free grammar") in [Chomsky normal form](https://en.wikipedia.org/wiki/Chomsky_normal_form "Chomsky normal form")
*   [Earley parser](https://en.wikipedia.org/wiki/Earley_parser "Earley parser"): Another O(n3) algorithm for parsing any [context-free grammar](https://en.wikipedia.org/wiki/Context-free_grammar "Context-free grammar")
*   [GLR parser](https://en.wikipedia.org/wiki/GLR_parser "GLR parser"):An algorithm for parsing any [context-free grammar](https://en.wikipedia.org/wiki/Context-free_grammar "Context-free grammar") by [Masaru Tomita](https://en.wikipedia.org/wiki/Masaru_Tomita "Masaru Tomita"). It is tuned for deterministic grammars, on which it performs almost [linear time](https://en.wikipedia.org/wiki/Linear_time "Linear time") and O(n3) in worst case.
*   [Inside-outside algorithm](https://en.wikipedia.org/wiki/Inside-outside_algorithm "Inside-outside algorithm"): An O(n3) algorithm for re-estimating production probabilities in [probabilistic context-free grammars](https://en.wikipedia.org/wiki/Probabilistic_context-free_grammar "Probabilistic context-free grammar")
*   [LL parser](https://en.wikipedia.org/wiki/LL_parser "LL parser"): A relatively simple [linear time](https://en.wikipedia.org/wiki/Linear_time "Linear time") parsing algorithm for a limited class of [context-free grammars](https://en.wikipedia.org/wiki/Context-free_grammar "Context-free grammar")
*   [LR parser](https://en.wikipedia.org/wiki/LR_parser "LR parser"): A more complex [linear time](https://en.wikipedia.org/wiki/Linear_time "Linear time") parsing algorithm for a larger class of [context-free grammars](https://en.wikipedia.org/wiki/Context-free_grammar "Context-free grammar"). Variants:
    *   [Canonical LR parser](https://en.wikipedia.org/wiki/Canonical_LR_parser "Canonical LR parser")
    *   [LALR (Look-ahead LR) parser](https://en.wikipedia.org/wiki/Look-ahead_LR_parser "Look-ahead LR parser")
    *   [Operator-precedence parser](https://en.wikipedia.org/wiki/Operator-precedence_parser "Operator-precedence parser")
    *   [SLR (Simple LR) parser](https://en.wikipedia.org/wiki/Simple_LR_parser "Simple LR parser")
    *   [Simple precedence parser](https://en.wikipedia.org/wiki/Simple_precedence_parser "Simple precedence parser")
*   [Packrat parser](https://en.wikipedia.org/wiki/Packrat_parser "Packrat parser"): A [linear time](https://en.wikipedia.org/wiki/Linear_time "Linear time") parsing algorithm supporting some [context-free grammars](https://en.wikipedia.org/wiki/Context-free_grammar "Context-free grammar") and [parsing expression grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar "Parsing expression grammar")
*   [Recursive descent parser](https://en.wikipedia.org/wiki/Recursive_descent_parser "Recursive descent parser"): A [top-down parser](https://en.wikipedia.org/wiki/Top-down_parsing "Top-down parsing") suitable for LL(_k_) grammars
*   [Shunting yard algorithm](https://en.wikipedia.org/wiki/Shunting_yard_algorithm "Shunting yard algorithm"): convert an infix-notation math expression to postfix
*   [Pratt parser](https://en.wikipedia.org/wiki/Pratt_parser "Pratt parser")
*   [Lexical analysis](https://en.wikipedia.org/wiki/Lexical_analysis "Lexical analysis")

### Quantum algorithms

Further information: [Quantum algorithm](https://en.wikipedia.org/wiki/Quantum_algorithm "Quantum algorithm")

*   [Deutsch‚ÄìJozsa algorithm](https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm "Deutsch‚ÄìJozsa algorithm"): criterion of balance for Boolean function
*   [Grover's algorithm](https://en.wikipedia.org/wiki/Grover%27s_algorithm "Grover's algorithm"): provides quadratic speedup for many search problems
*   [Shor's algorithm](https://en.wikipedia.org/wiki/Shor%27s_algorithm "Shor's algorithm"): provides [exponential](https://en.wikipedia.org/wiki/Exponential_function "Exponential function") speedup (relative to currently known non-quantum algorithms) for factoring a number
*   [Simon's algorithm](https://en.wikipedia.org/wiki/Simon%27s_algorithm "Simon's algorithm"): provides a provably [exponential](https://en.wikipedia.org/wiki/Exponential_function "Exponential function") speedup (relative to any non-quantum algorithm) for a black-box problem

### Theory of computation and automata

Further information: [Theory of computation](https://en.wikipedia.org/wiki/Theory_of_computation "Theory of computation")

*   [Hopcroft's algorithm](https://en.wikipedia.org/wiki/DFA_minimization#Hopcroft's_algorithm "DFA minimization"), [Moore's algorithm](https://en.wikipedia.org/wiki/DFA_minimization#Moore's_algorithm "DFA minimization"), and [Brzozowski's algorithm](https://en.wikipedia.org/wiki/DFA_minimization#Brzozowski's_algorithm "DFA minimization"): algorithms for [minimizing the number of states in a deterministic finite automaton](https://en.wikipedia.org/wiki/DFA_minimization "DFA minimization")
*   [Powerset construction](https://en.wikipedia.org/wiki/Powerset_construction "Powerset construction"): Algorithm to convert nondeterministic automaton to [deterministic automaton](https://en.wikipedia.org/wiki/Deterministic_automaton "Deterministic automaton").
*   [Tarski‚ÄìKuratowski algorithm](https://en.wikipedia.org/wiki/Tarski%E2%80%93Kuratowski_algorithm "Tarski‚ÄìKuratowski algorithm"): a [non-deterministic algorithm](https://en.wikipedia.org/wiki/Non-deterministic_algorithm "Non-deterministic algorithm") which provides an upper bound for the complexity of formulas in the [arithmetical hierarchy](https://en.wikipedia.org/wiki/Arithmetical_hierarchy "Arithmetical hierarchy") and [analytical hierarchy](https://en.wikipedia.org/wiki/Analytical_hierarchy "Analytical hierarchy")

Information theory and signal processing\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=53 "Edit section: Information theory and signal processing")\]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Main articles: [Information theory](https://en.wikipedia.org/wiki/Information_theory "Information theory") and [Signal processing](https://en.wikipedia.org/wiki/Signal_processing "Signal processing")

### Coding theory

Further information: [Coding theory](https://en.wikipedia.org/wiki/Coding_theory "Coding theory")

#### Error detection and correction

Further information: [Error detection and correction](https://en.wikipedia.org/wiki/Error_detection_and_correction "Error detection and correction")

*   [BCH Codes](https://en.wikipedia.org/wiki/BCH_Code "BCH Code")
    *   [Berlekamp‚ÄìMassey algorithm](https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm "Berlekamp‚ÄìMassey algorithm")
    *   [Peterson‚ÄìGorenstein‚ÄìZierler algorithm](https://en.wikipedia.org/wiki/Peterson%E2%80%93Gorenstein%E2%80%93Zierler_algorithm "Peterson‚ÄìGorenstein‚ÄìZierler algorithm")
    *   [Reed‚ÄìSolomon error correction](https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction "Reed‚ÄìSolomon error correction")
*   [BCJR algorithm](https://en.wikipedia.org/wiki/BCJR_algorithm "BCJR algorithm"): decoding of error correcting codes defined on trellises (principally convolutional codes)
*   [Forward error correction](https://en.wikipedia.org/wiki/Forward_error_correction "Forward error correction")
*   [Gray code](https://en.wikipedia.org/wiki/Gray_code "Gray code")
*   [Hamming codes](https://en.wikipedia.org/wiki/Hamming_code "Hamming code")
    *   [Hamming(7,4)](https://en.wikipedia.org/wiki/Hamming(7,4) "Hamming(7,4)"): a [Hamming code](https://en.wikipedia.org/wiki/Hamming_code "Hamming code") that encodes 4 bits of data into 7 bits by adding 3 parity bits
    *   [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance "Hamming distance"): sum number of positions which are different
    *   [Hamming weight](https://en.wikipedia.org/wiki/Hamming_weight "Hamming weight") (population count): find the number of 1 bits in a binary word
*   [Redundancy checks](https://en.wikipedia.org/wiki/Redundancy_check "Redundancy check")
    *   [Adler-32](https://en.wikipedia.org/wiki/Adler-32 "Adler-32")
    *   [Cyclic redundancy check](https://en.wikipedia.org/wiki/Cyclic_redundancy_check "Cyclic redundancy check")
    *   [Damm algorithm](https://en.wikipedia.org/wiki/Damm_algorithm "Damm algorithm")
    *   [Fletcher's checksum](https://en.wikipedia.org/wiki/Fletcher%27s_checksum "Fletcher's checksum")
    *   [Longitudinal redundancy check](https://en.wikipedia.org/wiki/Longitudinal_redundancy_check "Longitudinal redundancy check") (LRC)
    *   [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm "Luhn algorithm"): a method of validating identification numbers
    *   [Luhn mod N algorithm](https://en.wikipedia.org/wiki/Luhn_mod_N_algorithm "Luhn mod N algorithm"): extension of Luhn to non-numeric characters
    *   [Parity](https://en.wikipedia.org/wiki/Parity_bit "Parity bit"): simple/fast error detection technique
    *   [Verhoeff algorithm](https://en.wikipedia.org/wiki/Verhoeff_algorithm "Verhoeff algorithm")

#### Lossless compression algorithms

Main page: [Lossless compression algorithms](https://en.wikipedia.org/wiki/Category:Lossless_compression_algorithms "Category:Lossless compression algorithms")

*   [Burrows‚ÄìWheeler transform](https://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform "Burrows‚ÄìWheeler transform"): preprocessing useful for improving [lossless compression](https://en.wikipedia.org/wiki/Lossless_data_compression "Lossless data compression")
*   [Context tree weighting](https://en.wikipedia.org/wiki/Context_tree_weighting "Context tree weighting")
*   [Delta encoding](https://en.wikipedia.org/wiki/Delta_encoding "Delta encoding"): aid to compression of data in which sequential data occurs frequently
*   [Dynamic Markov compression](https://en.wikipedia.org/wiki/Dynamic_Markov_compression "Dynamic Markov compression"): Compression using predictive arithmetic coding
*   [Dictionary coders](https://en.wikipedia.org/wiki/Dictionary_coder "Dictionary coder")
    *   [Byte pair encoding](https://en.wikipedia.org/wiki/Byte_pair_encoding "Byte pair encoding") (BPE)
    *   [DEFLATE](https://en.wikipedia.org/wiki/DEFLATE_(algorithm) "DEFLATE (algorithm)")
    *   [Lempel‚ÄìZiv](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv "Lempel‚ÄìZiv")
        *   [LZ77 and LZ78](https://en.wikipedia.org/wiki/LZ77_and_LZ78 "LZ77 and LZ78")
        *   [Lempel‚ÄìZiv Jeff Bonwick](https://en.wikipedia.org/wiki/LZJB "LZJB") (LZJB)
        *   [Lempel‚ÄìZiv‚ÄìMarkov chain algorithm](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Markov_chain_algorithm "Lempel‚ÄìZiv‚ÄìMarkov chain algorithm") (LZMA)
        *   [Lempel‚ÄìZiv‚ÄìOberhumer](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Oberhumer "Lempel‚ÄìZiv‚ÄìOberhumer") (LZO): speed oriented
        *   [Lempel‚ÄìZiv‚ÄìStac](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Stac "Lempel‚ÄìZiv‚ÄìStac") (LZS)
        *   [Lempel‚ÄìZiv‚ÄìStorer‚ÄìSzymanski](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski "Lempel‚ÄìZiv‚ÄìStorer‚ÄìSzymanski") (LZSS)
        *   [Lempel‚ÄìZiv‚ÄìWelch](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch "Lempel‚ÄìZiv‚ÄìWelch") (LZW)
        *   [LZWL](https://en.wikipedia.org/wiki/LZWL "LZWL"): syllable-based variant
        *   [LZX](https://en.wikipedia.org/wiki/LZX "LZX")
        *   [Lempel‚ÄìZiv Ross Williams](https://en.wikipedia.org/wiki/LZRW "LZRW") (LZRW)
*   [Entropy encoding](https://en.wikipedia.org/wiki/Entropy_encoding "Entropy encoding"): coding scheme that assigns codes to symbols so as to match code lengths with the probabilities of the symbols
    *   [Arithmetic coding](https://en.wikipedia.org/wiki/Arithmetic_coding "Arithmetic coding"): advanced [entropy](https://en.wikipedia.org/wiki/Entropy "Entropy") coding
        *   [Range encoding](https://en.wikipedia.org/wiki/Range_encoding "Range encoding"): same as [arithmetic coding](https://en.wikipedia.org/wiki/Arithmetic_coding "Arithmetic coding"), but looked at in a slightly different way
    *   [Huffman coding](https://en.wikipedia.org/wiki/Huffman_coding "Huffman coding"): simple lossless compression taking advantage of relative character frequencies
        *   [Adaptive Huffman coding](https://en.wikipedia.org/wiki/Adaptive_Huffman_coding "Adaptive Huffman coding"): [adaptive coding](https://en.wikipedia.org/wiki/Adaptive_coding "Adaptive coding") technique based on Huffman coding
        *   [Package-merge algorithm](https://en.wikipedia.org/wiki/Package-merge_algorithm "Package-merge algorithm"): Optimizes Huffman coding subject to a length restriction on code strings
    *   [Shannon‚ÄìFano coding](https://en.wikipedia.org/wiki/Shannon%E2%80%93Fano_coding "Shannon‚ÄìFano coding")
    *   [Shannon‚ÄìFano‚ÄìElias coding](https://en.wikipedia.org/wiki/Shannon%E2%80%93Fano%E2%80%93Elias_coding "Shannon‚ÄìFano‚ÄìElias coding"): precursor to arithmetic encoding[\[1\]](#cite_note-1)
*   [Entropy coding with known entropy characteristics](https://en.wikipedia.org/wiki/Entropy_encoding "Entropy encoding")
    *   [Golomb coding](https://en.wikipedia.org/wiki/Golomb_coding "Golomb coding"): form of entropy coding that is optimal for alphabets following geometric distributions
    *   [Rice coding](https://en.wikipedia.org/wiki/Rice_coding "Rice coding"): form of entropy coding that is optimal for alphabets following geometric distributions
    *   [Truncated binary encoding](https://en.wikipedia.org/wiki/Truncated_binary_encoding "Truncated binary encoding")
    *   [Unary coding](https://en.wikipedia.org/wiki/Unary_coding "Unary coding"): code that represents a number n with n ones followed by a zero
    *   [Universal codes](https://en.wikipedia.org/wiki/Universal_code_(data_compression) "Universal code (data compression)"): encodes positive integers into binary code words
        *   Elias [delta](https://en.wikipedia.org/wiki/Elias_delta_coding "Elias delta coding"), [gamma](https://en.wikipedia.org/wiki/Elias_gamma_coding "Elias gamma coding"), and [omega](https://en.wikipedia.org/wiki/Elias_omega_coding "Elias omega coding") coding
        *   [Exponential-Golomb coding](https://en.wikipedia.org/wiki/Exponential-Golomb_coding "Exponential-Golomb coding")
        *   [Fibonacci coding](https://en.wikipedia.org/wiki/Fibonacci_coding "Fibonacci coding")
        *   [Levenshtein coding](https://en.wikipedia.org/wiki/Levenshtein_coding "Levenshtein coding")
*   [Fast Efficient & Lossless Image Compression System](https://en.wikipedia.org/wiki/FELICS "FELICS") (FELICS): a lossless image compression algorithm
*   [Incremental encoding](https://en.wikipedia.org/wiki/Incremental_encoding "Incremental encoding"): delta encoding applied to sequences of strings
*   [Prediction by partial matching](https://en.wikipedia.org/wiki/PPM_compression_algorithm "PPM compression algorithm") (PPM): an adaptive statistical data compression technique based on context modeling and prediction
*   [Run-length encoding](https://en.wikipedia.org/wiki/Run-length_encoding "Run-length encoding"): lossless data compression taking advantage of strings of repeated characters
*   [SEQUITUR algorithm](https://en.wikipedia.org/wiki/SEQUITUR_algorithm "SEQUITUR algorithm"): lossless compression by incremental grammar inference on a string

#### Lossy compression algorithms

Main page: [Lossy compression algorithms](https://en.wikipedia.org/wiki/Category:Lossy_compression_algorithms "Category:Lossy compression algorithms")

*   [3Dc](https://en.wikipedia.org/wiki/3Dc "3Dc"): a lossy data compression algorithm for [normal maps](https://en.wikipedia.org/wiki/Normal_mapping "Normal mapping")
*   [Audio](https://en.wikipedia.org/wiki/Audio_data_compression "Audio data compression") and [Speech](https://en.wikipedia.org/wiki/Speech_encoding "Speech encoding") compression
    *   [A-law algorithm](https://en.wikipedia.org/wiki/A-law_algorithm "A-law algorithm"): standard companding algorithm
    *   [Code-excited linear prediction](https://en.wikipedia.org/wiki/Code-excited_linear_prediction "Code-excited linear prediction") (CELP): low bit-rate speech compression
    *   [Linear predictive coding](https://en.wikipedia.org/wiki/Linear_predictive_coding "Linear predictive coding") (LPC): lossy compression by representing the [spectral envelope](https://en.wikipedia.org/wiki/Spectral_envelope "Spectral envelope") of a digital signal of speech in compressed form
    *   [Mu-law algorithm](https://en.wikipedia.org/wiki/Mu-law_algorithm "Mu-law algorithm"): standard analog signal compression or companding algorithm
    *   [Warped Linear Predictive Coding](https://en.wikipedia.org/wiki/Warped_Linear_Predictive_Coding "Warped Linear Predictive Coding") (WLPC)
*   [Image compression](https://en.wikipedia.org/wiki/Image_compression "Image compression")
    *   [Block Truncation Coding](https://en.wikipedia.org/wiki/Block_Truncation_Coding "Block Truncation Coding") (BTC): a type of lossy image compression technique for greyscale images
    *   [Embedded Zerotree Wavelet](https://en.wikipedia.org/wiki/Embedded_Zerotree_Wavelet "Embedded Zerotree Wavelet") (EZW)
    *   [Fast Cosine Transform algorithms](https://en.wikipedia.org/wiki/Fast_Cosine_Transform "Fast Cosine Transform") (FCT algorithms): compute Discrete Cosine Transform (DCT) efficiently
    *   [Fractal compression](https://en.wikipedia.org/wiki/Fractal_compression "Fractal compression"): method used to compress images using fractals
    *   [Set Partitioning in Hierarchical Trees](https://en.wikipedia.org/wiki/Set_Partitioning_in_Hierarchical_Trees "Set Partitioning in Hierarchical Trees") (SPIHT)
    *   [Wavelet compression](https://en.wikipedia.org/wiki/Wavelet_compression "Wavelet compression"): form of data compression well suited for [image compression](https://en.wikipedia.org/wiki/Image_compression "Image compression") (sometimes also video compression and audio compression)
*   [Transform coding](https://en.wikipedia.org/wiki/Transform_coding "Transform coding"): type of data compression for "natural" data like audio signals or photographic images
*   [Video compression](https://en.wikipedia.org/wiki/Video_compression "Video compression")
*   [Vector quantization](https://en.wikipedia.org/wiki/Vector_quantization "Vector quantization"): technique often used in lossy data compression

### Digital signal processing

Further information: [Digital signal processing](https://en.wikipedia.org/wiki/Digital_signal_processing "Digital signal processing")

*   [Adaptive-additive algorithm](https://en.wikipedia.org/wiki/Adaptive-additive_algorithm "Adaptive-additive algorithm") (AA algorithm): find the spatial frequency phase of an observed wave source
*   [Discrete Fourier transform](https://en.wikipedia.org/wiki/Discrete_Fourier_transform "Discrete Fourier transform"): determines the frequencies contained in a (segment of a) signal
    *   [Bluestein's FFT algorithm](https://en.wikipedia.org/wiki/Bluestein%27s_FFT_algorithm "Bluestein's FFT algorithm")
    *   [Bruun's FFT algorithm](https://en.wikipedia.org/wiki/Bruun%27s_FFT_algorithm "Bruun's FFT algorithm")
    *   [Cooley‚ÄìTukey FFT algorithm](https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm "Cooley‚ÄìTukey FFT algorithm")
    *   [Fast Fourier transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform "Fast Fourier transform")
    *   [Prime-factor FFT algorithm](https://en.wikipedia.org/wiki/Prime-factor_FFT_algorithm "Prime-factor FFT algorithm")
    *   [Rader's FFT algorithm](https://en.wikipedia.org/wiki/Rader%27s_FFT_algorithm "Rader's FFT algorithm")
*   [Fast folding algorithm](https://en.wikipedia.org/wiki/Fast_folding_algorithm "Fast folding algorithm"): an efficient algorithm for the detection of approximately periodic events within time series data
*   [Gerchberg‚ÄìSaxton algorithm](https://en.wikipedia.org/wiki/Gerchberg%E2%80%93Saxton_algorithm "Gerchberg‚ÄìSaxton algorithm"): Phase retrieval algorithm for optical planes
*   [Goertzel algorithm](https://en.wikipedia.org/wiki/Goertzel_algorithm "Goertzel algorithm"): identify a particular frequency component in a signal. Can be used for [DTMF](https://en.wikipedia.org/wiki/DTMF "DTMF") digit decoding.
*   [Karplus-Strong string synthesis](https://en.wikipedia.org/wiki/Karplus-Strong_string_synthesis "Karplus-Strong string synthesis"): physical modelling synthesis to simulate the sound of a hammered or plucked string or some types of percussion

#### Image processing

Further information: [Digital image processing](https://en.wikipedia.org/wiki/Digital_image_processing "Digital image processing")

*   Contrast Enhancement
    *   [Histogram equalization](https://en.wikipedia.org/wiki/Histogram_equalization "Histogram equalization"): use histogram to improve image contrast
    *   [Adaptive histogram equalization](https://en.wikipedia.org/wiki/Adaptive_histogram_equalization "Adaptive histogram equalization"): histogram equalization which adapts to local changes in contrast
*   [Connected-component labeling](https://en.wikipedia.org/wiki/Connected-component_labeling "Connected-component labeling"): find and label disjoint regions
*   [Dithering](https://en.wikipedia.org/wiki/Dithering "Dithering") and [half-toning](https://en.wikipedia.org/wiki/Half-toning "Half-toning")
    *   [Error diffusion](https://en.wikipedia.org/wiki/Error_diffusion "Error diffusion")
    *   [Floyd‚ÄìSteinberg dithering](https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering "Floyd‚ÄìSteinberg dithering")
    *   [Ordered dithering](https://en.wikipedia.org/wiki/Ordered_dithering "Ordered dithering")
    *   [Riemersma dithering](https://en.wikipedia.org/wiki/Riemersma_dithering "Riemersma dithering")
*   Elser [difference-map algorithm](https://en.wikipedia.org/wiki/Difference-map_algorithm "Difference-map algorithm"): a search algorithm for general constraint satisfaction problems. Originally used for [X-Ray diffraction](https://en.wikipedia.org/wiki/X-ray_crystallography "X-ray crystallography") microscopy
*   [Feature detection](https://en.wikipedia.org/wiki/Feature_detection_(computer_vision) "Feature detection (computer vision)")
    *   [Canny edge detector](https://en.wikipedia.org/wiki/Canny_edge_detector "Canny edge detector"): detect a wide range of edges in images
    *   [Generalised Hough transform](https://en.wikipedia.org/wiki/Generalised_Hough_transform "Generalised Hough transform")
    *   [Hough transform](https://en.wikipedia.org/wiki/Hough_transform "Hough transform")
    *   [Marr‚ÄìHildreth algorithm](https://en.wikipedia.org/wiki/Marr%E2%80%93Hildreth_algorithm "Marr‚ÄìHildreth algorithm"): an early [edge detection](https://en.wikipedia.org/wiki/Edge_detection "Edge detection") algorithm
    *   [SIFT](https://en.wikipedia.org/wiki/Scale-invariant_feature_transform "Scale-invariant feature transform") (Scale-invariant feature transform): is an algorithm to detect and describe local features in images.
    *   [SURF (Speeded Up Robust Features)](/w/index.php?title=SURF_(Speeded_Up_Robust_Features)&action=edit&redlink=1 "SURF (Speeded Up Robust Features) (page does not exist)"): is a robust local feature detector, first presented by Herbert Bay et al. in 2006, that can be used in computer vision tasks like object recognition or 3D reconstruction. It is partly inspired by the SIFT descriptor. The standard version of SURF is several times faster than SIFT and claimed by its authors to be more robust against different image transformations than SIFT.[\[2\]](#cite_note-2)[\[3\]](#cite_note-3)
*   [Richardson‚ÄìLucy deconvolution](https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution "Richardson‚ÄìLucy deconvolution"): image de-blurring algorithm
*   [Blind deconvolution](https://en.wikipedia.org/wiki/Blind_deconvolution "Blind deconvolution"): image de-blurring algorithm when [point spread function](https://en.wikipedia.org/wiki/Point_spread_function "Point spread function") is unknown.
*   [Median filtering](https://en.wikipedia.org/wiki/Median_filtering "Median filtering")
*   [Seam carving](https://en.wikipedia.org/wiki/Seam_carving "Seam carving"): content-aware image resizing algorithm
*   [Segmentation](https://en.wikipedia.org/wiki/Segmentation_(image_processing) "Segmentation (image processing)"): partition a digital image into two or more regions
    *   [GrowCut algorithm](https://en.wikipedia.org/wiki/GrowCut_algorithm "GrowCut algorithm"): an interactive segmentation algorithm
    *   [Random walker algorithm](https://en.wikipedia.org/wiki/Random_walker_algorithm "Random walker algorithm")
    *   [Region growing](https://en.wikipedia.org/wiki/Region_growing "Region growing")
    *   [Watershed transformation](https://en.wikipedia.org/wiki/Watershed_(algorithm) "Watershed (algorithm)"): a class of algorithms based on the watershed analogy

Software engineering\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=60 "Edit section: Software engineering")\]
---------------------------------------------------------------------------------------------------------------------------------

Further information: [Software engineering](https://en.wikipedia.org/wiki/Software_engineering "Software engineering")

*   [Cache algorithms](https://en.wikipedia.org/wiki/Cache_algorithms "Cache algorithms")
*   [CHS conversion](https://en.wikipedia.org/wiki/CHS_conversion "CHS conversion"): converting between disk addressing systems
*   [Double dabble](https://en.wikipedia.org/wiki/Double_dabble "Double dabble"): Convert binary numbers to BCD
*   [Hash Function](https://en.wikipedia.org/wiki/Hash_Function "Hash Function"): convert a large, possibly variable-sized amount of data into a small datum, usually a single integer that may serve as an index into an array
    *   [Fowler‚ÄìNoll‚ÄìVo hash function](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function "Fowler‚ÄìNoll‚ÄìVo hash function"): fast with low collision rate
    *   [Pearson hashing](https://en.wikipedia.org/wiki/Pearson_hashing "Pearson hashing"): computes 8 bit value only, optimized for 8 bit computers
    *   [Zobrist hashing](https://en.wikipedia.org/wiki/Zobrist_hashing "Zobrist hashing"): used in the implementation of [transposition tables](https://en.wikipedia.org/wiki/Transposition_table "Transposition table")
*   [Unicode Collation Algorithm](https://en.wikipedia.org/wiki/Unicode_Collation_Algorithm "Unicode Collation Algorithm")
*   [Xor swap algorithm](https://en.wikipedia.org/wiki/Xor_swap_algorithm "Xor swap algorithm"): swaps the values of two variables without using a buffer

Database algorithms\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=61 "Edit section: Database algorithms")\]
-------------------------------------------------------------------------------------------------------------------------------

Further information: [Database](https://en.wikipedia.org/wiki/Database "Database")

*   [Algorithms for Recovery and Isolation Exploiting Semantics](https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics "Algorithms for Recovery and Isolation Exploiting Semantics") (ARIES): [transaction](https://en.wikipedia.org/wiki/Transaction_(database) "Transaction (database)") recovery
*   [Join algorithms](https://en.wikipedia.org/wiki/Join_(SQL) "Join (SQL)")
    *   [Block nested loop](https://en.wikipedia.org/wiki/Block_nested_loop "Block nested loop")
    *   [Hash join](https://en.wikipedia.org/wiki/Hash_join "Hash join")
    *   [Nested loop join](https://en.wikipedia.org/wiki/Nested_loop_join "Nested loop join")
    *   [Sort-Merge Join](https://en.wikipedia.org/wiki/Sort-Merge_Join "Sort-Merge Join")

Distributed systems algorithms\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=62 "Edit section: Distributed systems algorithms")\]
-----------------------------------------------------------------------------------------------------------------------------------------------------

Further information: [Distributed algorithm](https://en.wikipedia.org/wiki/Distributed_algorithm "Distributed algorithm") and [Distributed systems](https://en.wikipedia.org/wiki/Distributed_systems "Distributed systems")

*   [Bully algorithm](https://en.wikipedia.org/wiki/Bully_algorithm "Bully algorithm"): a method for dynamically selecting a coordinator
*   [Byzantine fault tolerance](https://en.wikipedia.org/wiki/Byzantine_fault_tolerance "Byzantine fault tolerance"): good [fault tolerance](https://en.wikipedia.org/wiki/Fault-tolerant_system "Fault-tolerant system").
*   [Clock synchronization](https://en.wikipedia.org/wiki/Clock_synchronization "Clock synchronization")
    *   [Berkeley algorithm](https://en.wikipedia.org/wiki/Berkeley_algorithm "Berkeley algorithm")
    *   [Cristian's algorithm](https://en.wikipedia.org/wiki/Cristian%27s_algorithm "Cristian's algorithm")
    *   [Intersection algorithm](https://en.wikipedia.org/wiki/Intersection_algorithm "Intersection algorithm")
    *   [Marzullo's algorithm](https://en.wikipedia.org/wiki/Marzullo%27s_algorithm "Marzullo's algorithm")
*   Detection of Process Termination
    *   [Dijkstra-Scholten algorithm](https://en.wikipedia.org/wiki/Dijkstra-Scholten_algorithm "Dijkstra-Scholten algorithm")
    *   [Huang's algorithm](https://en.wikipedia.org/wiki/Huang%27s_algorithm "Huang's algorithm")
*   [Lamport ordering](https://en.wikipedia.org/wiki/Lamport_ordering "Lamport ordering"): a [partial ordering](https://en.wikipedia.org/wiki/Partial_order "Partial order") of events based on the _happened-before_ relation
*   [Mutual exclusion](https://en.wikipedia.org/wiki/Mutual_exclusion "Mutual exclusion")
    *   [Lamport's Distributed Mutual Exclusion Algorithm](https://en.wikipedia.org/wiki/Lamport%27s_Distributed_Mutual_Exclusion_Algorithm "Lamport's Distributed Mutual Exclusion Algorithm")
    *   [Naimi-Trehel's log(n) Algorithm](/w/index.php?title=Naimi-Trehel%27s_log(n)_Algorithm&action=edit&redlink=1 "Naimi-Trehel's log(n) Algorithm (page does not exist)")
    *   [Maekawa's Algorithm](https://en.wikipedia.org/wiki/Maekawa%27s_Algorithm "Maekawa's Algorithm")
    *   [Raymond's Algorithm](https://en.wikipedia.org/wiki/Raymond%27s_Algorithm "Raymond's Algorithm")
    *   [Ricart-Agrawala Algorithm](https://en.wikipedia.org/wiki/Ricart-Agrawala_Algorithm "Ricart-Agrawala Algorithm")
*   [Paxos algorithm](https://en.wikipedia.org/wiki/Paxos_algorithm "Paxos algorithm"): a family of protocols for solving consensus in a network of unreliable processors
*   [Raft (computer science)](https://en.wikipedia.org/wiki/Raft_(computer_science) "Raft (computer science)"): a consensus algorithm designed as an alternative to Paxos
*   [Snapshot algorithm](https://en.wikipedia.org/wiki/Snapshot_algorithm "Snapshot algorithm"): record a consistent global state for an asynchronous system
    *   [Chandy-Lamport algorithm](https://en.wikipedia.org/wiki/Chandy-Lamport_algorithm "Chandy-Lamport algorithm")
*   [Vector clocks](https://en.wikipedia.org/wiki/Vector_clocks "Vector clocks"): generate a [partial ordering](https://en.wikipedia.org/wiki/Partial_ordering "Partial ordering") of events in a distributed system and detect [causality](https://en.wikipedia.org/wiki/Causality "Causality") violations

### Memory allocation and deallocation algorithms

*   [Buddy memory allocation](https://en.wikipedia.org/wiki/Buddy_memory_allocation "Buddy memory allocation"): Algorithm to allocate memory such that fragmentation is less.
*   [Garbage collectors](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science) "Garbage collection (computer science)")
    *   [Cheney's algorithm](https://en.wikipedia.org/wiki/Cheney%27s_algorithm "Cheney's algorithm"): An improvement on the [Semi-space collector](/w/index.php?title=Semi-space_collector&action=edit&redlink=1 "Semi-space collector (page does not exist)")
    *   [Generational garbage collector](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science) "Garbage collection (computer science)"): Fast garbage collectors that segregate memory by age
    *   [Mark-compact algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm "Mark-compact algorithm"): a combination of the [mark-sweep algorithm](https://en.wikipedia.org/wiki/Mark_and_sweep "Mark and sweep") and [Cheney's copying algorithm](https://en.wikipedia.org/wiki/Cheney%27s_algorithm "Cheney's algorithm")
    *   [Mark and sweep](https://en.wikipedia.org/wiki/Mark_and_sweep "Mark and sweep")
    *   [Semi-space collector](/w/index.php?title=Semi-space_collector&action=edit&redlink=1 "Semi-space collector (page does not exist)"): An early copying collector
*   [Reference counting](https://en.wikipedia.org/wiki/Reference_counting "Reference counting")

Networking\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=64 "Edit section: Networking")\]
-------------------------------------------------------------------------------------------------------------

Further information: [Network scheduler](https://en.wikipedia.org/wiki/Network_scheduler "Network scheduler")

*   [Karn's algorithm](https://en.wikipedia.org/wiki/Karn%27s_algorithm "Karn's algorithm"): addresses the problem of getting accurate estimates of the round-trip time for messages when using TCP
*   [Lule√• algorithm](https://en.wikipedia.org/wiki/Lule%C3%A5_algorithm "Lule√• algorithm"): a technique for storing and searching internet routing tables efficiently
*   [Network congestion](https://en.wikipedia.org/wiki/Network_congestion "Network congestion")
    *   [Exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff "Exponential backoff")
    *   [Nagle's algorithm](https://en.wikipedia.org/wiki/Nagle%27s_algorithm "Nagle's algorithm"): improve the efficiency of TCP/IP networks by coalescing packets
    *   [Truncated binary exponential backoff](https://en.wikipedia.org/wiki/Truncated_binary_exponential_backoff "Truncated binary exponential backoff")

Operating systems algorithms
-------------------------------------------------------------------------------------------------------------------------------------------------

Further information: [Operating systems](https://en.wikipedia.org/wiki/Operating_systems "Operating systems")

*   [Banker's algorithm](https://en.wikipedia.org/wiki/Banker%27s_algorithm "Banker's algorithm"): Algorithm used for deadlock avoidance.
*   [Page replacement algorithms](https://en.wikipedia.org/wiki/Page_replacement_algorithms "Page replacement algorithms"): Selecting the victim page under low memory conditions.
    *   [Adaptive replacement cache](https://en.wikipedia.org/wiki/Adaptive_replacement_cache "Adaptive replacement cache"): better performance than LRU
    *   [Clock with Adaptive Replacement](https://en.wikipedia.org/wiki/Clock_with_Adaptive_Replacement "Clock with Adaptive Replacement") (CAR): is a page replacement algorithm that has performance comparable to [Adaptive replacement cache](https://en.wikipedia.org/wiki/Adaptive_replacement_cache "Adaptive replacement cache")

### Process synchronization\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=66 "Edit section: Process synchronization")\]

Further information: [Process synchronization](https://en.wikipedia.org/wiki/Process_synchronization "Process synchronization")

Further information: [Process scheduler](https://en.wikipedia.org/wiki/Process_scheduler "Process scheduler")

*   [Dekker's algorithm](https://en.wikipedia.org/wiki/Dekker%27s_algorithm "Dekker's algorithm")
*   [Lamport's Bakery algorithm](https://en.wikipedia.org/wiki/Lamport%27s_Bakery_algorithm "Lamport's Bakery algorithm")
*   [Peterson's algorithm](https://en.wikipedia.org/wiki/Peterson%27s_algorithm "Peterson's algorithm")

### Scheduling

Further information: [Scheduling (computing)](https://en.wikipedia.org/wiki/Scheduling_(computing) "Scheduling (computing)")

*   [Earliest deadline first scheduling](https://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling "Earliest deadline first scheduling")
*   [Fair-share scheduling](https://en.wikipedia.org/wiki/Fair-share_scheduling "Fair-share scheduling")
*   [Least slack time scheduling](https://en.wikipedia.org/wiki/Least_slack_time_scheduling "Least slack time scheduling")
*   [List scheduling](https://en.wikipedia.org/wiki/List_scheduling "List scheduling")
*   [Multi level feedback queue](https://en.wikipedia.org/wiki/Multi_level_feedback_queue "Multi level feedback queue")
*   [Rate-monotonic scheduling](https://en.wikipedia.org/wiki/Rate-monotonic_scheduling "Rate-monotonic scheduling")
*   [Round-robin scheduling](https://en.wikipedia.org/wiki/Round-robin_scheduling "Round-robin scheduling")
*   [Shortest job next](https://en.wikipedia.org/wiki/Shortest_job_next "Shortest job next")
*   [Shortest remaining time](https://en.wikipedia.org/wiki/Shortest_remaining_time "Shortest remaining time")
*   [Top-nodes algorithm](https://en.wikipedia.org/wiki/Top-nodes_algorithm "Top-nodes algorithm"): resource calendar management

### I/O scheduling

Further information: [I/O scheduling](https://en.wikipedia.org/wiki/I/O_scheduling "I/O scheduling")

[![[icon]](//upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/20px-Wiki_letter_w_cropped.svg.png)](https://en.wikipedia.org/wiki/File:Wiki_letter_w_cropped.svg)

This section **needs expansion**. You can help by [adding to it](https://en.wikipedia.org/w/index.php?title=List_of_algorithms&action=edit&section=). _(July 2017)_

#### Disk scheduling

*   [Elevator algorithm](https://en.wikipedia.org/wiki/Elevator_algorithm "Elevator algorithm"): Disk scheduling algorithm that works like an elevator.
*   [Shortest seek first](https://en.wikipedia.org/wiki/Shortest_seek_first "Shortest seek first"): Disk scheduling algorithm to reduce [seek time](https://en.wikipedia.org/wiki/Seek_time "Seek time").

See also\[[edit](/w/index.php?title=List_of_algorithms&action=edit&section=70 "Edit section: See also")\]
---------------------------------------------------------------------------------------------------------

*   [List of data structures](https://en.wikipedia.org/wiki/List_of_data_structures "List of data structures")
*   [List of machine learning algorithms](https://en.wikipedia.org/wiki/List_of_machine_learning_algorithms "List of machine learning algorithms")
*   [List of pathfinding algorithms](https://en.wikipedia.org/wiki/List_of_pathfinding_algorithms "List of pathfinding algorithms")
*   [List of algorithm general topics](https://en.wikipedia.org/wiki/List_of_algorithm_general_topics "List of algorithm general topics")
*   [List of terms relating to algorithms and data structures](https://en.wikipedia.org/wiki/List_of_terms_relating_to_algorithms_and_data_structures "List of terms relating to algorithms and data structures")
*   [Heuristic](https://en.wikipedia.org/wiki/Heuristic "Heuristic")

References
-------------------------------------------------------------------------------------------------------------

1.  **[^](#cite_ref-1)** [\[1\]](https://wayback.archive-it.org/all/20090325200343/http://www.ece.msstate.edu/~fowler/Classes/ECE8813/Handouts/shannon_fano_elias.pdf)
2.  **[^](#cite_ref-2)** [\[2\]](https://web.archive.org/web/20070221214147/http://www.vision.ee.ethz.ch/~surf/eccv06.pdf)
3.  **[^](#cite_ref-3)** ["Archived copy"](https://web.archive.org/web/20131006113018/http://glorfindel.mavrinac.com/~aaron/school/pdf/bay06_surf.pdf) (PDF). Archived from [the original](http://glorfindel.mavrinac.com/~aaron/school/pdf/bay06_surf.pdf) (PDF) on 2013-10-06. Retrieved 2013-10-05.CS1 maint: archived copy as title ([link](https://en.wikipedia.org/wiki/Category:CS1_maint:_archived_copy_as_title "Category:CS1 maint: archived copy as title"))

![](//en.wikipedia.orghttps://en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1)

Retrieved from "[https://en.wikipedia.org/w/index.php?title=List\_of\_algorithms&oldid=925021392](https://en.wikipedia.org/w/index.php?title=List_of_algorithms&oldid=925021392)"

*   [Algorithms](https://en.wikipedia.org/wiki/Category:Algorithms "Category:Algorithms")
*   [Mathematics-related lists](https://en.wikipedia.org/wiki/Category:Mathematics-related_lists "Category:Mathematics-related lists")
*   [Optimization algorithms and methods](https://en.wikipedia.org/wiki/Category:Optimization_algorithms_and_methods "Category:Optimization algorithms and methods")
